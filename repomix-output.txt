This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-19T20:31:00.871Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.eslintrc.json
.github/workflows/nextjs.yml
.gitignore
jest.config.js
next.config.js
package.json
postcss.config.mjs
public/_redirects
public/404.html
public/file.svg
public/globe.svg
public/images/README.md
public/manifest.webmanifest
public/next.svg
public/vercel.svg
public/window.svg
README.md
scripts/create-nojekyll.js
scripts/find-feature-types.ps1
scripts/find-interfaces.ps1
scripts/fix-imports-v6.js
scripts/fix-imports.js
scripts/reorganise-components.js
scripts/reorganise-features.js
scripts/reorganize-types.js
scripts/update-types.js
serve.json
src/app/about/page.tsx
src/app/error.tsx
src/app/history/page.tsx
src/app/layout.tsx
src/app/not-found.tsx
src/app/page.tsx
src/app/replay/page.tsx
src/components/common/CentredImage/index.tsx
src/components/common/Instructions/index.tsx
src/components/common/Instructions/types.ts
src/components/common/Navigation/index.tsx
src/components/common/OfflineIndicator/index.tsx
src/components/common/PWAPrompt/index.tsx
src/components/features/Cards/components/AnimatedCard.tsx
src/components/features/Cards/components/Card.tsx
src/components/features/Cards/components/CardContent.tsx
src/components/features/Cards/components/CardControls.tsx
src/components/features/Cards/components/CardMoveOptions.tsx
src/components/features/Cards/components/index.ts
src/components/features/Cards/components/MobileCardActions/index.tsx
src/components/features/Cards/components/styles.ts
src/components/features/Cards/hooks/useCardDragAnimation.ts
src/components/features/Cards/types.ts
src/components/features/Categories/components/CategoryColumn/index.tsx
src/components/features/Categories/components/Mobile/CategorySelectionOverlay.tsx
src/components/features/Categories/constants/categories.ts
src/components/features/Categories/types.ts
src/components/features/Categories/utils/categoryUtils.ts
src/components/features/Game/commands/BaseCommand.ts
src/components/features/Game/commands/Command.ts
src/components/features/Game/commands/DropCommand.ts
src/components/features/Game/commands/MoveCommand.ts
src/components/features/Game/components/CoreValueReasoning/index.tsx
src/components/features/Game/components/Results/index.tsx
src/components/features/Game/components/StartScreen/index.tsx
src/components/features/Game/components/StartScreen/types.ts
src/components/features/Game/hooks/useCommands.ts
src/components/features/Game/hooks/useGameState.ts
src/components/features/Game/hooks/useSession.ts
src/components/features/Game/types.ts
src/components/features/Game/utils/index.ts
src/components/features/Game/utils/sessionUtils.ts
src/components/features/Game/utils/valuesUtils.ts
src/components/features/History/components/SessionList/index.tsx
src/components/features/History/types.ts
src/components/features/Replay/components/MobileReplayCategories/index.tsx
src/components/features/Replay/components/ReplayClient/index.tsx
src/components/features/Replay/components/ReplayColumn/index.tsx
src/components/features/Replay/hooks/useCardAnimation.ts
src/components/features/Replay/hooks/useReplayState.ts
src/components/features/Replay/types.ts
src/components/features/Round/CategoryGrid.tsx
src/components/features/Round/components/Mobile/MobileCardControls.tsx
src/components/features/Round/components/Mobile/MobileCategoryRow.tsx
src/components/features/Round/components/Mobile/MobileSelectionOverlay.tsx
src/components/features/Round/components/MobileCardView.tsx
src/components/features/Round/components/MobileCategoryList.tsx
src/components/features/Round/components/StatusMessage.tsx
src/components/features/Round/hooks/useMobileInteractions.ts
src/components/features/Round/hooks/useMobileView.ts
src/components/features/Round/hooks/useRoundHandlers.ts
src/components/features/Round/hooks/useRoundState.ts
src/components/features/Round/hooks/useRoundStatus.ts
src/components/features/Round/hooks/useRoundValidation.ts
src/components/features/Round/index.ts
src/components/features/Round/RoundActions.tsx
src/components/features/Round/RoundHeader.tsx
src/components/features/Round/RoundUI.tsx
src/components/features/Round/RoundUIDebug.tsx
src/components/features/Round/types.ts
src/components/features/Round/utils/categoryUtils.ts
src/config/config.json
src/data/values.json
src/hooks/useSessionReconstruction.ts
src/lib/contexts/MobileContext.tsx
src/lib/db/indexedDB.ts
src/lib/hooks/useAnimation.ts
src/lib/hooks/usePWA.ts
src/lib/store/store.ts
src/lib/types/Animation.ts
src/lib/types/BaseCommand.ts
src/lib/types/Categories.ts
src/lib/types/Category.ts
src/lib/types/CategoryName.ts
src/lib/types/Command.ts
src/lib/types/CompletedSession.ts
src/lib/types/Context.ts
src/lib/types/DropCommandPayload.ts
src/lib/types/index.ts
src/lib/types/MoveCommandPayload.ts
src/lib/types/Position.ts
src/lib/types/PWA.ts
src/lib/types/Round.ts
src/lib/types/serviceWorker.d.ts
src/lib/types/Session.ts
src/lib/types/SessionReconstruction.ts
src/lib/types/Store.ts
src/lib/types/Value.ts
src/lib/utils/animation/index.ts
src/lib/utils/animation/transitions.ts
src/lib/utils/animation/variants.ts
src/lib/utils/cache/index.ts
src/lib/utils/config/envUtils.ts
src/lib/utils/config/gameConfig.ts
src/lib/utils/config/index.ts
src/lib/utils/debug/index.ts
src/lib/utils/dom/index.ts
src/lib/utils/email/emailUtils.ts
src/lib/utils/index.ts
src/lib/utils/storage/cacheUtils.ts
src/lib/utils/storage/index.ts
src/lib/utils/storage/storeUtils.ts
src/lib/worker/index.ts
src/styles/globals.css
tailwind.config.ts
tests/components/Card.test.tsx
tests/setup.ts
tests/utils/mockData.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .eslintrc.json
================
{
  "extends": [
    "next",
    "next/core-web-vitals"
  ],
  "rules": {
    "@next/next/no-img-element": "off"
  }
}

================
File: .github/workflows/nextjs.yml
================
name: Deploy Next.js site to Pages

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Install dependencies
        run: npm ci
      - name: Update Version
        run: |
          echo "NEXT_PUBLIC_VERSION=$(node -p "require('./package.json').version")-$(date +'%Y%m%d.%H%M')" >> $GITHUB_ENV
      - name: Build with Next.js
        env:
          NODE_ENV: production
        run: |
          npm run build
          touch out/.nojekyll
          # Add cache control headers
          echo '/*' > out/_headers
          echo '  Cache-Control: no-cache, no-store, must-revalidate' >> out/_headers
          # Ensure manifest has correct content type
          echo '/manifest.webmanifest' >> out/_headers
          echo '  Content-Type: application/manifest+json' >> out/_headers
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./out

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# PWA files
/public/sw.js
/public/workbox-*.js
/public/worker-*.js
/public/sw.js.map
/public/workbox-*.js.map
/public/worker-*.js.map
/public/fallback-*.js

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for commiting if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: jest.config.js
================
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './',
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};

module.exports = createJestConfig(customJestConfig);

================
File: next.config.js
================
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true, // Changed to true
  disable: process.env.NODE_ENV === 'development',
  buildExcludes: [/middleware-manifest\.json$/],
  publicExcludes: ['!manifest.webmanifest'],
  runtimeCaching: [
    {
      urlPattern: /^https?.*/,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'core-values-cache',
        expiration: {
          maxEntries: 200,
          maxAgeSeconds: 24 * 60 * 60 // 24 hours
        },
        networkTimeoutSeconds: 10,
        backgroundSync: {
          name: 'core-values-queue',
          options: {
            maxRetentionTime: 24 * 60 // Retry for max of 24 Hours
          }
        }
      }
    }
  ]
})

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  output: 'export',
  images: {
    unoptimized: true
  },
  basePath: process.env.NODE_ENV === 'production' ? '' : '',
  webpack: (config) => {
    config.experiments = {
      ...config.experiments,
      asyncWebAssembly: false,
      syncWebAssembly: false,
    };
    return config;
  },
  env: {
    BUILD_TIME: new Date().toISOString(),
    CACHE_VERSION: Date.now().toString(),
    NEXT_PUBLIC_VERSION: process.env.NEXT_PUBLIC_VERSION || require('./package.json').version
  }
}

module.exports = withPWA(nextConfig);

================
File: package.json
================
{
  "name": "digitalanalogue9.github.io",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "clean": "rimraf .next && rimraf node_modules/.cache",
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "export": "next export",
    "test:watch": "jest --watch",
    "reorganise": "node scripts/reorganise-features.js"
  },
  "dependencies": {
    "@heroicons/react": "^2.1.5",
    "framer-motion": "^11.11.11",
    "idb": "^8.0.0",
    "next": "^15.0.3",
    "next-pwa": "^5.6.0",
    "react": "^18.3.1",
    "react-dnd": "^16.0.1",
    "react-dnd-html5-backend": "^16.0.1",
    "react-dom": "^18.3.1",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@babel/generator": "^7.26.2",
    "@babel/parser": "^7.26.2",
    "@babel/traverse": "^7.25.9",
    "@babel/types": "^7.26.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.0.1",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.9.0",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.14.0",
    "eslint-config-next": "15.0.3",
    "fs-extra": "^11.2.0",
    "glob": "^11.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "typescript": "^5.6.3"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;

================
File: public/_redirects
================
/*    /index.html   200
/digitalanalogue9.github.io/*    /index.html   200

================
File: public/404.html
================
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Core Values</title>
    <script type="text/javascript">
        var pathSegmentsToKeep = 1;
        var l = window.location;
        l.replace(
            l.protocol + '//' + l.hostname + (l.port ? ':' + l.port : '') +
            '/digitalanalogue9.github.io/' +
            l.pathname.split('/').slice(pathSegmentsToKeep + 1).join('/') +
            (l.search ? l.search : '') +
            l.hash
        );
    </script>
</head>
<body>
</body>
</html>

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/images/README.md
================
This directory contains public images used in the application.

Best practices:
1. Use descriptive names for images
2. Use lowercase with hyphens for filenames (e.g., core-values-logo.png)
3. Include image optimization where possible
4. Consider using Next.js Image component for automatic optimization

================
File: public/manifest.webmanifest
================
{
  "name": "Core Values",
  "short_name": "Core Values",
  "description": "Discover and prioritise your personal values",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3b82f6",
  "orientation" : "portrait",
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

# Core Values Application

A web application to help individuals discover and prioritise their personal values through an interactive card sorting exercise.

## Features

- Interactive drag-and-drop interface for sorting values
- Multiple rounds of refinement 
- Progress saving using IndexedDB
- History view of previous sessions
- Printable results
- Responsive design
## Getting Started

First, run the development server:

### Prerequisites

- Node.js 18.x or higher
- npm 9.x or higher

### Installation

1. Clone the repository:
```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
git clone https://github.com/digitalanalogue9/digitalanalogue9.github.io.git
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: scripts/create-nojekyll.js
================
const fs = require('fs');
const path = require('path');

const nojekyllPath = path.join(process.cwd(), 'out', '.nojekyll');

try {
  fs.writeFileSync(nojekyllPath, '');
  console.log('.nojekyll file created successfully');
} catch (err) {
  console.error('Error creating .nojekyll file:', err);
  process.exit(1);
}

================
File: scripts/find-feature-types.ps1
================
$srcPath = "src/components/features"
$features = Get-ChildItem -Path $srcPath -Directory

foreach ($feature in $features) {
    Write-Output "`nAnalyzing feature: $($feature.Name)"
    
    # Check if types.ts exists
    $typesFile = Join-Path $feature.FullName "types.ts"
    if (Test-Path $typesFile) {
        Write-Output "✓ Has types.ts"
    } else {
        Write-Output "✗ No types.ts file"
    }
    
    # Find files with interface definitions
    Write-Output "`nSearching for interface definitions..."
    $files = Get-ChildItem -Path $feature.FullName -Recurse -Include *.ts,*.tsx |
        Where-Object { $_.Name -ne "types.ts" }
    
    foreach ($file in $files) {
        $content = Get-Content $file.FullName -Raw
        if ($content -match "export\s+interface\s+\w+") {
            Write-Output "`nFile with interfaces: $($file.FullName)"
            $matches = [regex]::Matches($content, "(?ms)export\s+interface\s+\w+[^{]*{[^}]*}")
            foreach ($match in $matches) {
                Write-Output "`nInterface found:"
                Write-Output $match.Value
            }
        }
    }
}

================
File: scripts/find-interfaces.ps1
================
$searchPath = "src"
$pattern = "export\s+interface\s+\w+"

Write-Output "Scanning for interface definitions in $searchPath..."
Write-Output "----------------------------------------`n"

Get-ChildItem -Path $searchPath -Recurse -Include *.tsx,*.ts | 
Where-Object { $_.Name -ne "types.ts" } |
ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    if ($content -match $pattern) {
        Write-Output "File: $($_.FullName)"
        # Extract and display the interface definitions
        $matches = [regex]::Matches($content, "(?ms)export\s+interface\s+\w+[^{]*{[^}]*}")
        foreach ($match in $matches) {
            Write-Output "`nInterface found:"
            Write-Output $match.Value
            Write-Output "----------------------------------------"
        }
    }
}

Write-Output "`nScan complete."

================
File: scripts/fix-imports-v6.js
================
const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;

const ROOT = process.cwd();
const SRC = path.join(ROOT, 'src');

const importMappings = {
  // Types
  '@/types': '@/lib/types',
  '@/types/Value': '@/lib/types',

  // Commands
  '@/commands/DropCommand': '@/components/features/Game/commands/DropCommand',
  '@/commands/MoveCommand': '@/components/features/Game/commands/MoveCommand',
  '@/commands/BaseCommand': '@/components/features/Game/commands/BaseCommand',
  '@/commands': '@/components/features/Game/commands',

  // Components
  '@/components/Round': '@/components/features/Round',
  '@/components/Card': '@/components/features/Cards/components',
  '@/components/Results': '@/components/features/Game/components/Results',
  '@/components/StartScreen': '@/components/features/Game/components/StartScreen',
  '@/components/Instructions': '@/components/common/Instructions',
  '@/components/PWAPrompt': '@/components/common/PWAPrompt',
  '@/components/CategoryColumn': '@/components/features/Categories/components/CategoryColumn',
  '../components/Round': '@/components/features/Round',
  '../components/StartScreen': '@/components/features/Game/components/StartScreen',
  '../components/Instructions': '@/components/common/Instructions',
  '../CategoryColumn': '@/components/features/Categories/components/CategoryColumn',
  './Card': '@/components/features/Cards/components',

  // Hooks
  '@/hooks/useGameState': '@/components/features/Game/hooks/useGameState',
  '@/hooks/useSession': '@/components/features/Game/hooks/useSession',
  '@/hooks/useCommands': '@/components/features/Game/hooks/useCommands',
  '@/hooks/usePWA': '@/lib/hooks/usePWA',
  '../hooks/useGameState': '@/components/features/Game/hooks/useGameState',
  '../hooks/useSession': '@/components/features/Game/hooks/useSession',
  '../hooks/usePWA': '@/lib/hooks/usePWA',

  // Utils
  '@/utils': '@/lib/utils',
  '@/utils/storage': '@/lib/utils/storage',
  '@/utils/cache': '@/lib/utils/cache',
  '../utils/storage': '@/lib/utils/storage',
  '@/utils/debug/renderLogger': '@/lib/utils/debug/renderLogger',
  '@/utils/config': '@/lib/utils/config',
  '@/utils/categoryUtils': '@/components/features/Categories/utils/categoryUtils',

  // DB
  '@/db/indexedDB': '@/lib/db/indexedDB',
  '../db/indexedDB': '@/lib/db/indexedDB',

  // Store
  '@/store/store': '@/lib/store/store',

  // Contexts
  '@/contexts/MobileContext': '@/lib/contexts/MobileContext',

  // Data
  '../data/values.json': '@/data/values.json',
};

async function updateImports(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    let modified = false;

    // Parse the file
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    // Track any imports that weren't mapped
    const unmappedImports = new Set();

    traverse(ast, {
      ImportDeclaration(path) {
        const importPath = path.node.source.value;
        let wasUpdated = false;

        // Handle both absolute and relative imports
        if (importPath.startsWith('@/') || importPath.startsWith('.')) {
          for (const [oldPath, newPath] of Object.entries(importMappings)) {
            if (importPath === oldPath || importPath.startsWith(oldPath + '/')) {
              path.node.source.value = importPath.replace(oldPath, newPath);
              modified = true;
              wasUpdated = true;
              break;
            }
          }

          if (!wasUpdated && (importPath.startsWith('@/') || importPath.startsWith('..'))) {
            unmappedImports.add(importPath);
          }
        }
      }
    });

    if (modified) {
      const output = generate(ast, {}, content);
      await fs.writeFile(filePath, output.code);
      console.log(`✓ Updated imports in: ${filePath}`);
    }

    if (unmappedImports.size > 0) {
      console.log(`\n⚠️  Unmapped imports in ${filePath}:`);
      unmappedImports.forEach(imp => console.log(`   ${imp}`));
    }

  } catch (error) {
    console.error(`\n✗ Error processing ${filePath}:`, error.message);
    console.error(`   File: ${filePath}`);
  }
}

async function main() {
  try {
    console.log('Starting import path updates...');
    
    // Get all TypeScript/JavaScript files
    const files = glob.sync('**/*.{ts,tsx}', {
      cwd: SRC,
      absolute: true,
      nodir: true,
      windowsPathsNoEscape: true
    });
    
    console.log(`Found ${files.length} files to process`);

    if (files.length === 0) {
      console.log('No files found to process');
      return;
    }

    // Sort files to process in a predictable order
    files.sort();
    
    let processedCount = 0;
    let errorCount = 0;
    
    // Process each file
    for (const file of files) {
      try {
        await updateImports(file);
        processedCount++;
      } catch (error) {
        errorCount++;
        console.error(`Failed to process ${file}:`, error);
      }
    }

    console.log('\nImport updates complete!');
    console.log(`Processed ${processedCount} files`);
    if (errorCount > 0) console.log(`Encountered ${errorCount} errors`);

  } catch (error) {
    console.error('Error during import updates:', error);
    process.exit(1);
  }
}

main();

================
File: scripts/fix-imports.js
================
const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;

const ROOT = process.cwd();
const SRC = path.join(ROOT, 'src');

// Comprehensive import mappings based on the new structure
const importMappings = {
  // Base mappings for major sections
  '@/components/features': '@/components/features',
  '@/components/common': '@/components/common',
  '@/lib': '@/lib',

  // Feature-specific mappings
  '@/components/Round': '@/components/features/Round',
  '@/components/Card': '@/components/features/Cards/components',
  '@/components/History': '@/components/features/History/components',
  '@/components/Replay': '@/components/features/Replay/components',
  '@/components/CategoryColumn': '@/components/features/Categories/components/CategoryColumn',
  '@/components/StartScreen': '@/components/features/Game/components/StartScreen',
  '@/components/Results': '@/components/features/Game/components/Results',
  '@/components/CoreValueReasoning': '@/components/features/Game/components/CoreValueReasoning',

  // Common components
  '@/components/Navigation': '@/components/common/Navigation',
  '@/components/Instructions': '@/components/common/Instructions',
  '@/components/PWAPrompt': '@/components/common/PWAPrompt',
  '@/components/OfflineIndicator': '@/components/common/OfflineIndicator',
  '@/components/CentredImage': '@/components/common/CentredImage',

  // Hooks
  '@/hooks/useGameState': '@/components/features/Game/hooks/useGameState',
  '@/hooks/useCommands': '@/components/features/Game/hooks/useCommands',
  '@/hooks/useSession': '@/components/features/Game/hooks/useSession',
  '@/hooks/useCardDragAnimation': '@/components/features/Cards/hooks/useCardDragAnimation',
  '@/hooks/useSessionReconstruction': '@/components/features/Replay/hooks/useSessionReconstruction',
  '@/hooks/useAnimation': '@/lib/hooks/useAnimation',
  '@/hooks/usePWA': '@/lib/hooks/usePWA',

  // Utils
  '@/utils/storage': '@/lib/utils/storage',
  '@/utils/cache': '@/lib/utils/cache',
  '@/utils/email': '@/lib/utils/email',
  '@/utils/dom': '@/lib/utils/dom',
  '@/utils/config': '@/lib/utils/config',
  '@/utils/animation': '@/lib/utils/animation',
  '@/utils/debug': '@/lib/utils/debug',
  '@/utils/game': '@/components/features/Game/utils',
  '@/utils/categoryUtils': '@/components/features/Categories/utils/categoryUtils',

  // Types
  '@/types': '@/lib/types',

  // Other core items
  '@/db': '@/lib/db',
  '@/store': '@/lib/store',
  '@/contexts': '@/lib/contexts',
  '@/constants': '@/components/features/Categories/constants',

  // Relative path mappings
  '../components/Round': '@/components/features/Round',
  '../components/StartScreen': '@/components/features/Game/components/StartScreen',
  '../components/Instructions': '@/components/common/Instructions',
  '../components/Navigation': '@/components/common/Navigation',
  '../components/PWAPrompt': '@/components/common/PWAPrompt',
  '../hooks/useGameState': '@/components/features/Game/hooks/useGameState',
  '../hooks/useSession': '@/components/features/Game/hooks/useSession',
  '../hooks/usePWA': '@/lib/hooks/usePWA',
  '../db/indexedDB': '@/lib/db/indexedDB',
  '../utils/storage': '@/lib/utils/storage',
  '../utils/cache': '@/lib/utils/cache',
  '../data/values.json': '@/data/values.json'
};

function createRelativeMapping(importPath) {
  // Convert relative paths to absolute paths for consistent handling
  if (importPath.startsWith('../')) {
    const absolutePath = importPath.replace('../', '@/');
    for (const [oldPath, newPath] of Object.entries(importMappings)) {
      if (absolutePath.startsWith(oldPath)) {
        return newPath + absolutePath.slice(oldPath.length);
      }
    }
  }
  return null;
}

async function updateImports(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    let modified = false;

    // Parse the file
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    // Track any imports that weren't mapped
    const unmappedImports = new Set();

    traverse(ast, {
      ImportDeclaration(path) {
        const importPath = path.node.source.value;
        let wasUpdated = false;

        // Handle relative paths
        if (importPath.startsWith('../')) {
          const newPath = createRelativeMapping(importPath);
          if (newPath) {
            path.node.source.value = newPath;
            modified = true;
            wasUpdated = true;
          }
        } 
        // Handle absolute paths
        else if (importPath.startsWith('@/')) {
          for (const [oldPath, newPath] of Object.entries(importMappings)) {
            if (importPath.startsWith(oldPath)) {
              path.node.source.value = importPath.replace(oldPath, newPath);
              modified = true;
              wasUpdated = true;
              break;
            }
          }
        }

        if (!wasUpdated && (importPath.startsWith('@/') || importPath.startsWith('..'))) {
          unmappedImports.add(importPath);
        }
      }
    });

    if (modified) {
      const output = generate(ast, {}, content);
      await fs.writeFile(filePath, output.code);
      console.log(`✓ Updated imports in: ${filePath}`);
    }

    if (unmappedImports.size > 0) {
      console.log(`\n⚠️  Unmapped imports in ${filePath}:`);
      unmappedImports.forEach(imp => console.log(`   ${imp}`));
    }

  } catch (error) {
    console.error(`\n✗ Error processing ${filePath}:`, error.message);
    console.error(`   File: ${filePath}`);
  }
}

async function main() {
    try {
        console.log('Starting import path updates...');
        console.log('Source directory:', SRC);

        // Modified glob pattern for Windows
        const files = glob.sync('**/*.{ts,tsx}', {
            cwd: SRC,
            absolute: true,
            nodir: true,
            windowsPathsNoEscape: true
        });

        console.log(`Found ${files.length} files to process`);

        if (files.length === 0) {
            console.log('Searched in:', SRC);
            console.log('No files found. Please check the path.');
            return;
        }

        // Sort files to process in a predictable order
        files.sort();

        // Log first few files to verify correct paths
        console.log('\nFirst few files to process:');
        files.slice(0, 5).forEach(f => console.log(f));

        let processedCount = 0;
        let errorCount = 0;

        // Process each file
        for (const file of files) {
            try {
                await updateImports(file);
                processedCount++;
            } catch (error) {
                errorCount++;
                console.error(`Failed to process ${file}:`, error);
            }
        }

        console.log('\nImport updates complete!');
        console.log(`Processed ${processedCount} files`);
        if (errorCount > 0) console.log(`Encountered ${errorCount} errors`);

    } catch (error) {
        console.error('Error during import updates:', error);
        process.exit(1);
    }
}

main();

================
File: scripts/reorganise-components.js
================
const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;
const t = require('@babel/types');
const readline = require('readline');

const ROOT = process.cwd();

// Create readline interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const question = (query) => new Promise((resolve) => rl.question(query, resolve));

// Define the desired order of sections
const SECTION_ORDER = [
  'imports',
  'interfaces',
  'types',
  'constants',
  'refs',
  'hooks',
  'state',
  'effects',
  'handlers',
  'render'
];

function identifySection(node) {
  if (t.isVariableDeclaration(node)) {
    // Check for useState
    if (node.declarations.some(dec => 
      t.isCallExpression(dec.init) && 
      t.isIdentifier(dec.init.callee) && 
      dec.init.callee.name === 'useState'
    )) {
      return 'state';
    }
    
    // Check for useRef
    if (node.declarations.some(dec => 
      t.isCallExpression(dec.init) && 
      t.isIdentifier(dec.init.callee) && 
      dec.init.callee.name === 'useRef'
    )) {
      return 'refs';
    }
    
    // Check for other hooks
    if (node.declarations.some(dec => 
      t.isCallExpression(dec.init) && 
      t.isIdentifier(dec.init.callee) && 
      dec.init.callee.name.startsWith('use')
    )) {
      return 'hooks';
    }

    // Check for constants
    if (node.kind === 'const' && !node.declarations.some(dec => 
      t.isCallExpression(dec.init) && 
      t.isIdentifier(dec.init.callee) && 
      dec.init.callee.name.startsWith('use')
    )) {
      return 'constants';
    }
  }

  // Check for useEffect
  if (t.isExpressionStatement(node) && 
      t.isCallExpression(node.expression) && 
      t.isIdentifier(node.expression.callee) && 
      node.expression.callee.name === 'useEffect') {
    return 'effects';
  }

  // Check for handlers
  if (t.isFunctionDeclaration(node) || 
      (t.isVariableDeclaration(node) && 
       node.declarations.some(dec => 
         t.isArrowFunctionExpression(dec.init) || 
         t.isFunctionExpression(dec.init)
       ))) {
    const name = t.isFunctionDeclaration(node) ? 
      node.id.name : 
      node.declarations[0].id.name;
    if (name.startsWith('handle') || name.includes('Handler')) {
      return 'handlers';
    }
  }

  // Check for interfaces and types
  if (t.isTSInterfaceDeclaration(node)) {
    return 'interfaces';
  }
  if (t.isTSTypeAliasDeclaration(node)) {
    return 'types';
  }

  return null;
}

async function analyzeComponent(filePath) {
  const content = await fs.readFile(filePath, 'utf-8');
  const issues = [];
  
  try {
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    let componentBody = null;
    let currentSectionOrder = [];

    traverse(ast, {
      FunctionDeclaration(path) {
        if (path.node.body.type === 'BlockStatement') {
          componentBody = path;
          path.node.body.body.forEach(node => {
            const section = identifySection(node);
            if (section) {
              currentSectionOrder.push(section);
            }
          });
        }
      },
      ArrowFunctionExpression(path) {
        if (path.node.body.type === 'BlockStatement') {
          componentBody = path;
          path.node.body.body.forEach(node => {
            const section = identifySection(node);
            if (section) {
              currentSectionOrder.push(section);
            }
          });
        }
      }
    });

    if (!componentBody) {
      return null;
    }

    // Check for section order issues
    let lastSectionIndex = -1;
    currentSectionOrder.forEach((section, index) => {
      const sectionIndex = SECTION_ORDER.indexOf(section);
      if (sectionIndex < lastSectionIndex) {
        issues.push(`${section} appears after ${SECTION_ORDER[lastSectionIndex]}`);
      }
      lastSectionIndex = Math.max(lastSectionIndex, sectionIndex);
    });

    return {
      hasIssues: issues.length > 0,
      issues,
      currentOrder: currentSectionOrder
    };

  } catch (error) {
    console.error(`Error analyzing ${filePath}:`, error);
    return null;
  }
}

async function analyzeComponentStructure(filePath) {
  const content = await fs.readFile(filePath, 'utf-8');
  const details = {
    stateDeclarations: [],
    hooksUsed: [],
    effectsCount: 0,
    handlersCount: 0,
    orderIssues: []
  };
  
  try {
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    traverse(ast, {
      VariableDeclaration(path) {
        path.node.declarations.forEach(dec => {
          // Collect state declarations
          if (t.isCallExpression(dec.init) && 
              t.isIdentifier(dec.init.callee) && 
              dec.init.callee.name === 'useState') {
            if (t.isArrayPattern(dec.id)) {
              const stateName = dec.id.elements[0].name;
              details.stateDeclarations.push(stateName);
            }
          }
          
          // Collect hook usage
          if (t.isCallExpression(dec.init) && 
              t.isIdentifier(dec.init.callee) && 
              dec.init.callee.name.startsWith('use')) {
            details.hooksUsed.push(dec.init.callee.name);
          }
        });
      },
      
      CallExpression(path) {
        if (t.isIdentifier(path.node.callee) && 
            path.node.callee.name === 'useEffect') {
          details.effectsCount++;
        }
      },
      
      FunctionDeclaration(path) {
        if (path.node.id.name.startsWith('handle')) {
          details.handlersCount++;
        }
      },
      
      ArrowFunctionExpression(path) {
        const parentNode = path.parent;
        if (t.isVariableDeclarator(parentNode) && 
            t.isIdentifier(parentNode.id) && 
            parentNode.id.name.startsWith('handle')) {
          details.handlersCount++;
        }
      }
    });

    return details;

  } catch (error) {
    console.error(`Error analyzing structure of ${filePath}:`, error);
    return null;
  }
}

async function reorganizeComponent(filePath) {
  const content = await fs.readFile(filePath, 'utf-8');
  
  try {
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    let componentBody = null;
    let sections = {
      imports: [],
      interfaces: [],
      types: [],
      constants: [],
      refs: [],
      hooks: [],
      state: [],
      effects: [],
      handlers: [],
      render: []
    };

    traverse(ast, {
      Program(path) {
        // Handle top-level imports
        path.node.body.forEach(node => {
          if (t.isImportDeclaration(node)) {
            sections.imports.push(node);
          }
        });
      },
      
      FunctionDeclaration(path) {
        if (path.node.body.type === 'BlockStatement') {
          componentBody = path;
        }
      },
      
      ArrowFunctionExpression(path) {
        if (path.node.body.type === 'BlockStatement') {
          componentBody = path;
        }
      }
    });

    if (!componentBody) {
      return false;
    }

    // Categorize statements
    componentBody.node.body.body.forEach(node => {
      const section = identifySection(node);
      if (section) {
        sections[section].push(node);
      } else {
        sections.render.push(node);
      }
    });

    // Rebuild the body in the correct order
    const newBody = [];
    SECTION_ORDER.forEach(section => {
      if (sections[section].length > 0) {
        newBody.push(t.commentBlock(` ${section} `, true));
        newBody.push(...sections[section]);
        newBody.push(t.emptyStatement());
      }
    });

    componentBody.node.body.body = newBody;

    const output = generate(ast, {
      retainLines: true,
      comments: true
    }, content);

    await fs.writeFile(filePath, output.code);
    return true;

  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
    return false;
  }
}

async function main() {
  try {
    console.log('Analyzing components...\n');
    
    // Find all component files
    const files = glob.sync(path.join(ROOT, 'src', 'components', '**', '*.tsx'));
    
    // Filter out index files and type files
    const componentFiles = files.filter(file => 
      !file.endsWith('index.tsx') && 
      !file.endsWith('.types.tsx') &&
      !file.includes('.test.') &&
      !file.endsWith('Props.tsx')
    );

    // Analyze all components first
    const analysisResults = [];
    for (const file of componentFiles) {
      const analysis = await analyzeComponent(file);
      const details = await analyzeComponentStructure(file);
      if ((analysis && analysis.hasIssues) || details) {
        analysisResults.push({
          file,
          ...analysis,
          details
        });
      }
    }

    if (analysisResults.length === 0) {
      console.log('No components need reorganization.');
      rl.close();
      return;
    }

    // Ask what to do
    const answer = await question(
      'Would you like to:\n' +
      '1. Show detailed report only (no changes)\n' +
      '2. Fix all components\n' +
      '3. Fix components one by one\n' +
      '4. Exit\n' +
      'Enter your choice (1-4): '
    );

    switch (answer) {
      case '1':
        console.log('\nDetailed Component Analysis:\n');
        analysisResults.forEach(({ file, issues, details }) => {
          console.log(`\nFile: ${path.relative(ROOT, file)}`);
          console.log('----------------------------------------');
          if (issues && issues.length > 0) {
            console.log('\nOrder Issues:');
            issues.forEach(issue => console.log(`  - ${issue}`));
          }
          if (details) {
            console.log('\nComponent Structure:');
            if (details.stateDeclarations.length > 0) {
              console.log(`  State declarations (${details.stateDeclarations.length}):`);
              details.stateDeclarations.forEach(state => console.log(`    - ${state}`));
            }
            if (details.hooksUsed.length > 0) {
              console.log(`  Hooks used (${details.hooksUsed.length}):`);
              details.hooksUsed.forEach(hook => console.log(`    - ${hook}`));
            }
            console.log(`  Effects count: ${details.effectsCount}`);
            console.log(`  Handlers count: ${details.handlersCount}`);
          }
          console.log('----------------------------------------\n');
        });
        break;

      case '2':
        console.log('\nFixing all components...');
        for (const { file } of analysisResults) {
          const success = await reorganizeComponent(file);
          console.log(`${success ? '✓' : '✗'} ${path.relative(ROOT, file)}`);
        }
        break;

      case '3':
        console.log('\nFixing components one by one...');
        for (const { file } of analysisResults) {
          const shouldFix = await question(`Fix ${path.relative(ROOT, file)}? (y/n): `);
          if (shouldFix.toLowerCase() === 'y') {
            const success = await reorganizeComponent(file);
            console.log(`${success ? '✓' : '✗'} ${path.relative(ROOT, file)}`);
          }
        }
        break;

      case '4':
      default:
        console.log('Exiting without making changes.');
        break;
    }

    console.log('\nDone!');
    rl.close();

  } catch (error) {
    console.error('Error during component analysis:', error);
    rl.close();
    process.exit(1);
  }
}

main();

================
File: scripts/reorganise-features.js
================
const fs = require('fs-extra');
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;
const t = require('@babel/types');
const glob = require('glob');

const ROOT = process.cwd();
const SRC = path.join(ROOT, 'src');

// File movement mapping
const moves = {
  // Game Feature
  game: {
    base: 'src/components/features/Game',
    moves: [
      { from: 'src/components/Round', to: 'components/Round' },
      { from: 'src/components/Results.tsx', to: 'components/Results/index.tsx' },
      { from: 'src/components/StartScreen.tsx', to: 'components/StartScreen/index.tsx' },
      { from: 'src/components/StartScreenProps.tsx', to: 'components/StartScreen/types.ts' },
      { from: 'src/components/CoreValueReasoning.tsx', to: 'components/CoreValueReasoning/index.tsx' },
      { from: 'src/commands', to: 'commands' },
      { from: 'src/hooks/useGameState.ts', to: 'hooks/useGameState.ts' },
      { from: 'src/hooks/useCommands.ts', to: 'hooks/useCommands.ts' },
      { from: 'src/hooks/useSession.ts', to: 'hooks/useSession.ts' },
      { from: 'src/utils/game', to: 'utils' }
    ]
  },

  // Cards Feature
  cards: {
    base: 'src/components/features/Cards',
    moves: [
      { from: 'src/components/Card', to: 'components' },
      { from: 'src/hooks/useCardDragAnimation.ts', to: 'hooks/useCardDragAnimation.ts' },
      { from: 'src/components/Mobile/MobileCardActions.tsx', to: 'components/MobileCardActions/index.tsx' }
    ]
  },

  // Categories Feature
  categories: {
    base: 'src/components/features/Categories',
    moves: [
      { from: 'src/components/CategoryColumn.tsx', to: 'components/CategoryColumn/index.tsx' },
      { from: 'src/components/CategoryColumnProps.tsx', to: 'components/CategoryColumn/types.ts' },
      { from: 'src/constants/categories.ts', to: 'constants/categories.ts' },
      { from: 'src/utils/categoryUtils.ts', to: 'utils/categoryUtils.ts' },
      { from: 'src/components/Mobile/CategorySelectionOverlay.tsx', to: 'components/Mobile/CategorySelectionOverlay.tsx' }
    ]
  },

  // History Feature
  history: {
    base: 'src/components/features/History',
    moves: [
      { from: 'src/components/History/SessionList.tsx', to: 'components/SessionList/index.tsx' }
    ]
  },

  // Replay Feature
  replay: {
    base: 'src/components/features/Replay',
    moves: [
      { from: 'src/components/Replay/ReplayClient.tsx', to: 'components/ReplayClient/index.tsx' },
      { from: 'src/components/Replay/components/ReplayColumn.tsx', to: 'components/ReplayColumn/index.tsx' },
      { from: 'src/components/Replay/components/MobileReplayCategories.tsx', to: 'components/MobileReplayCategories/index.tsx' },
      { from: 'src/components/Replay/hooks/useCardAnimation.ts', to: 'hooks/useCardAnimation.ts' },
      { from: 'src/components/Replay/hooks/useReplayState.ts', to: 'hooks/useReplayState.ts' }
    ]
  },

  // Common Components
  common: {
    base: 'src/components/common',
    moves: [
      { from: 'src/components/Navigation.tsx', to: 'Navigation/index.tsx' },
      { from: 'src/components/Instructions.tsx', to: 'Instructions/index.tsx' },
      { from: 'src/components/InstructionsProps.tsx', to: 'Instructions/types.ts' },
      { from: 'src/components/OfflineIndicator.tsx', to: 'OfflineIndicator/index.tsx' },
      { from: 'src/components/PWAPrompt.tsx', to: 'PWAPrompt/index.tsx' },
      { from: 'src/components/CentredImage.tsx', to: 'CentredImage/index.tsx' }
    ]
  },

  // Library
  lib: {
    base: 'src/lib',
    moves: [
      { from: 'src/contexts/MobileContext.tsx', to: 'contexts/MobileContext.tsx' },
      { from: 'src/store', to: 'store' },
      { from: 'src/db', to: 'db' },
      { from: 'src/types', to: 'types' },
      { from: 'src/worker', to: 'worker' },
      { from: 'src/utils/animation', to: 'utils/animation' },
      { from: 'src/utils/cache', to: 'utils/cache' },
      { from: 'src/utils/config', to: 'utils/config' },
      { from: 'src/utils/dom', to: 'utils/dom' },
      { from: 'src/utils/storage', to: 'utils/storage' },
      { from: 'src/utils/debug', to: 'utils/debug' },
      { from: 'src/hooks/useAnimation.ts', to: 'hooks/useAnimation.ts' },
      { from: 'src/hooks/usePWA.ts', to: 'hooks/usePWA.ts' }
    ]
  },

  // Assets
  assets: {
    base: 'src',
    moves: [
      { from: 'src/app/globals.css', to: 'styles/globals.css' },
      { from: 'src/app/fonts', to: 'assets/fonts' }
    ]
  }
};

// Import mappings for updating import statements
const importMappings = {
  '@/components/Card': '@/features/Cards',
  '@/components/Round': '@/features/Game/components/Round',
  '@/components/Mobile': '@/features/Mobile',
  '@/components/History': '@/features/History',
  '@/components/Replay': '@/features/Replay',
  '@/hooks/useGameState': '@/features/Game/hooks/useGameState',
  '@/hooks/useCommands': '@/features/Game/hooks/useCommands',
  '@/hooks/useSession': '@/features/Game/hooks/useSession',
  '@/hooks/useCardDragAnimation': '@/features/Cards/hooks/useCardDragAnimation',
  '@/contexts/MobileContext': '@/lib/contexts/MobileContext',
  '@/utils/game': '@/features/Game/utils',
  '@/utils/categoryUtils': '@/features/Categories/utils/categoryUtils',
  '@/constants/categories': '@/features/Categories/constants/categories',
  '@/types': '@/lib/types',
  '@/store': '@/lib/store',
  '@/db': '@/lib/db',
  '@/worker': '@/lib/worker'
};

async function createDirectories() {
  const allDirs = Object.values(moves).map(({ base }) => base);
  for (const dir of allDirs) {
    await fs.ensureDir(path.join(ROOT, dir));
    console.log(`Created directory: ${dir}`);
  }
}

async function moveFiles() {
  for (const feature of Object.values(moves)) {
    for (const move of feature.moves) {
      const fromPath = path.join(ROOT, move.from);
      const toPath = path.join(ROOT, feature.base, move.to);
      
      try {
        if (await fs.pathExists(fromPath)) {
          await fs.ensureDir(path.dirname(toPath));
          await fs.move(fromPath, toPath, { overwrite: true });
          console.log(`Moved: ${move.from} -> ${feature.base}/${move.to}`);
        } else {
          console.log(`Source not found: ${move.from}`);
        }
      } catch (error) {
        console.error(`Error moving ${move.from}:`, error);
      }
    }
  }
}

async function updateImports(filePath) {
  const content = await fs.readFile(filePath, 'utf-8');
  
  try {
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    let modified = false;

    traverse(ast, {
      ImportDeclaration(path) {
        const importPath = path.node.source.value;
        
        for (const [oldPath, newPath] of Object.entries(importMappings)) {
          if (importPath.startsWith(oldPath)) {
            path.node.source.value = importPath.replace(oldPath, newPath);
            modified = true;
            break;
          }
        }
      }
    });

    if (modified) {
      const output = generate(ast, {}, content);
      await fs.writeFile(filePath, output.code);
      console.log(`Updated imports in: ${filePath}`);
    }
  } catch (error) {
    console.error(`Error processing imports in ${filePath}:`, error);
  }
}

async function updateAllImports() {
  const files = glob.sync(path.join(SRC, '**/*.{ts,tsx}'));
  for (const file of files) {
    await updateImports(file);
  }
}

async function updateTsConfig() {
  const tsconfigPath = path.join(ROOT, 'tsconfig.json');
  const tsconfig = await fs.readJSON(tsconfigPath);

  tsconfig.compilerOptions.paths = {
    "@/*": ["./src/*"],
    "@/components/*": ["./src/components/*"],
    "@/features/*": ["./src/components/features/*"],
    "@/common/*": ["./src/components/common/*"],
    "@/lib/*": ["./src/lib/*"],
    "@/styles/*": ["./src/styles/*"],
    "@/assets/*": ["./src/assets/*"]
  };

  await fs.writeJSON(tsconfigPath, tsconfig, { spaces: 2 });
  console.log('Updated tsconfig.json paths');
}

async function main() {
  try {
    console.log('Starting codebase reorganization...');
    await createDirectories();
    await moveFiles();
    await updateAllImports();
    await updateTsConfig();
    console.log('Reorganization complete!');
  } catch (error) {
    console.error('Error during reorganization:', error);
    process.exit(1);
  }
}

main();

================
File: scripts/reorganize-types.js
================
const fs = require('fs-extra');
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;

const ROOT = process.cwd();

// Define the interface movements
const typesMoves = {
  'Round': {
    targetFile: 'src/components/features/Round/types.ts',
    sourcesToRemove: [
      'src/components/features/Round/components/StatusMessageProps.tsx',
      'src/components/features/Round/CategoryGridProps.ts',
      'src/components/features/Round/RoundActionsProps.ts',
      'src/components/features/Round/RoundHeaderProps.ts',
      'src/components/features/Round/RoundUIProps.ts'
    ],
    interfaces: [
      'StatusMessageProps',
      'StatusState',
      'CategoryGridProps',
      'RoundActionsProps',
      'RoundHeaderProps',
      'RoundUIProps'
    ]
  },
  'Categories': {
    targetFile: 'src/components/features/Categories/types.ts',
    sourcesToRemove: [
      'src/components/features/Categories/components/Mobile/CategorySelectionOverlay.tsx'
    ],
    interfaces: [
      'CategorySelectionOverlayProps'
    ]
  }
};

async function extractInterfaces(filePath) {
  const content = await fs.readFile(filePath, 'utf-8');
  const ast = parser.parse(content, {
    sourceType: 'module',
    plugins: ['typescript', 'jsx']
  });

  const interfaces = [];
  let imports = new Set();

  traverse(ast, {
    ImportDeclaration(path) {
      imports.add(path.node.source.value);
    },
    TSInterfaceDeclaration(path) {
      if (path.node.id.name) {
        const interfaceCode = generate(path.node).code;
        interfaces.push(interfaceCode);
      }
    }
  });

  return { interfaces, imports: Array.from(imports) };
}

async function updateTypesFile(featureKey, move) {
  const targetPath = path.join(ROOT, move.targetFile);
  let content = '// Generated types file\n\n';

  // Add imports
  content += `import { Categories, CategoryName, Value } from "@/lib/types";\n\n`;

  // Extract interfaces from source files
  for (const sourceFile of move.sourcesToRemove) {
    const sourcePath = path.join(ROOT, sourceFile);
    if (await fs.pathExists(sourcePath)) {
      const { interfaces } = await extractInterfaces(sourcePath);
      content += interfaces.join('\n\n') + '\n\n';
    }
  }

  // Write the types file
  await fs.ensureFile(targetPath);
  await fs.writeFile(targetPath, content);
  console.log(`✓ Updated types file: ${move.targetFile}`);

  // Remove interfaces from original files
  for (const sourceFile of move.sourcesToRemove) {
    const sourcePath = path.join(ROOT, sourceFile);
    if (await fs.pathExists(sourcePath)) {
      const content = await fs.readFile(sourcePath, 'utf-8');
      const ast = parser.parse(content, {
        sourceType: 'module',
        plugins: ['typescript', 'jsx']
      });

      let modified = false;
      traverse(ast, {
        TSInterfaceDeclaration(path) {
          if (move.interfaces.includes(path.node.id.name)) {
            path.remove();
            modified = true;
          }
        }
      });

      if (modified) {
        // Add import for the types
        const importStatement = `import type { ${move.interfaces.join(', ')} } from '../types';\n`;
        const output = importStatement + generate(ast).code;
        await fs.writeFile(sourcePath, output);
        console.log(`✓ Updated source file: ${sourceFile}`);
      }
    }
  }
}

async function main() {
  try {
    console.log('Starting types reorganization...');
    
    for (const [featureKey, move] of Object.entries(typesMoves)) {
      await updateTypesFile(featureKey, move);
    }

    console.log('\nTypes reorganization complete!');
    console.log('\nNext steps:');
    console.log('1. Review the generated types files');
    console.log('2. Update any imports that might be affected');
    console.log('3. Run TypeScript compiler to check for any issues');

  } catch (error) {
    console.error('Error during types reorganization:', error);
    process.exit(1);
  }
}

main();

================
File: scripts/update-types.js
================
const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;

const ROOT = process.cwd();

// Files to remove
const propsFilesToRemove = [
  'src/components/features/Round/CategoryGridProps.ts',
  'src/components/features/Round/RoundActionsProps.ts',
  'src/components/features/Round/RoundHeaderProps.ts',
  'src/components/features/Round/RoundUIProps.ts',
  'src/components/features/Round/components/StatusMessageProps.tsx',
  'src/components/features/Categories/components/CategoryColumn/types.ts',
  'src/components/features/Cards/components/types.ts'
];

// Update Round/types.ts with StatusState interface
async function updateRoundTypes() {
  const roundTypesPath = path.join(ROOT, 'src/components/features/Round/types.ts');
  const statusHookPath = path.join(ROOT, 'src/components/features/Round/hooks/useRoundStatus.ts');

  try {
    // Read the StatusState interface from useRoundStatus.ts
    const hookContent = await fs.readFile(statusHookPath, 'utf-8');
    const ast = parser.parse(hookContent, {
      sourceType: 'module',
      plugins: ['typescript']
    });

    let statusStateInterface = '';
    traverse(ast, {
      TSInterfaceDeclaration(path) {
        if (path.node.id.name === 'StatusState') {
          statusStateInterface = generate(path.node).code;
        }
      }
    });

    // Add it to types.ts if it's not already there
    const typesContent = await fs.readFile(roundTypesPath, 'utf-8');
    if (!typesContent.includes('interface StatusState')) {
      const updatedContent = `${typesContent}\n\n${statusStateInterface}\n`;
      await fs.writeFile(roundTypesPath, updatedContent);
    }

    // Remove interface from useRoundStatus.ts
    const updatedHookContent = hookContent.replace(/export\s+interface\s+StatusState[\s\S]*?}\n/, '');
    await fs.writeFile(statusHookPath, updatedHookContent);

    console.log('✓ Updated Round types');
  } catch (error) {
    console.error('Error updating Round types:', error);
  }
}

// Update imports in all files to use the new type locations
async function updateImports(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const ast = parser.parse(content, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx']
    });

    let modified = false;

    traverse(ast, {
      ImportDeclaration(path) {
        const importPath = path.node.source.value;
        // Update imports to use feature-level types
        if (importPath.includes('/components/types')) {
          path.node.source.value = importPath.replace('/components/types', '/types');
          modified = true;
        }
        // Update relative Props imports to use types
        if (importPath.endsWith('Props') || importPath.includes('/types')) {
          const currentDir = path.dirname(filePath);
          const featureDir = findFeatureDir(currentDir);
          if (featureDir) {
            path.node.source.value = path.relative(currentDir, path.join(featureDir, 'types'));
            if (!path.node.source.value.startsWith('.')) {
              path.node.source.value = './' + path.node.source.value;
            }
            modified = true;
          }
        }
      }
    });

    if (modified) {
      const output = generate(ast, {}, content);
      await fs.writeFile(filePath, output.code);
      console.log(`✓ Updated imports in: ${filePath}`);
    }
  } catch (error) {
    console.error(`Error updating imports in ${filePath}:`, error);
  }
}

// Helper function to find the feature directory
function findFeatureDir(dir) {
  const parts = dir.split(path.sep);
  const featuresIndex = parts.indexOf('features');
  if (featuresIndex === -1) return null;
  return parts.slice(0, featuresIndex + 2).join(path.sep);
}

// Remove Props files
async function removePropsFiles() {
  for (const file of propsFilesToRemove) {
    const filePath = path.join(ROOT, file);
    try {
      if (await fs.pathExists(filePath)) {
        await fs.remove(filePath);
        console.log(`✓ Removed: ${file}`);
      }
    } catch (error) {
      console.error(`Error removing ${file}:`, error);
    }
  }
}

async function main() {
  try {
    console.log('Updating types organization...');
    
    // Remove Props files
    await removePropsFiles();

    // Update Round types
    await updateRoundTypes();

    // Update imports in all TypeScript files
    const files = glob.sync(path.join(ROOT, 'src', '**', '*.{ts,tsx}'));
    for (const file of files) {
      await updateImports(file);
    }

    console.log('\nTypes update complete!');

  } catch (error) {
    console.error('Error during types update:', error);
    process.exit(1);
  }
}

main();

================
File: serve.json
================
{
  "public": "out",
  "directoryListing": false,
  "cleanUrls": false,
  "trailingSlash": true,
  "headers": [
    {
      "source": "**/*.js",
      "headers": [
        {
          "key": "Content-Type",
          "value": "application/javascript"
        }
      ]
    },
    {
      "source": "**/*.css",
      "headers": [
        {
          "key": "Content-Type",
          "value": "text/css"
        }
      ]
    }
  ],
  "rewrites": [
    {
      "source": "/**",
      "destination": "/index.html"
    }
  ]
}

================
File: src/app/about/page.tsx
================
// src/app/about/page.tsx
'use client'

import React, { useEffect, useState } from 'react';

const appVersion = process.env.NEXT_PUBLIC_VERSION || '0.0.0';

export default function About() {
  const [showInstructions, setShowInstructions] = useState(true);

  useEffect(() => {
    const savedPreference = localStorage.getItem('showInstructions');
    setShowInstructions(savedPreference !== 'false');
  }, []);

  const handleToggleInstructions = () => {
    const newValue = !showInstructions;
    setShowInstructions(newValue);
    localStorage.setItem('showInstructions', newValue ? 'true' : 'false');
  };

  return (
    <div className="flex-1 overflow-y-auto">
      <div className="max-w-3xl mx-auto p-6 space-y-8">
        <div className="max-w-3xl mx-auto p-6 space-y-8">
          <div className="text-center mb-12">
            <h1 className="text-3xl font-bold text-gray-900 mb-4">
              About Core Values
            </h1>
            <p className="text-xl text-gray-600">
              Discover and prioritise what matters most to you
            </p>
            <p className="text-sm text-gray-500 mt-2" aria-label="Application version">
              Version {appVersion}
            </p>
          </div>
          <section aria-labelledby="why-matters-heading">
            <h2 id="why-matters-heading" className="text-2xl font-bold text-gray-900">
              Why Core Values Matter
            </h2>
            <div className="prose prose-lg text-gray-600">
              <p>
                Understanding your core values is essential for making meaningful life decisions
                and living authentically. This app helps you explore and organize your values
                through an interactive and thoughtful process.
              </p>
              <p>
                Whether you are at a crossroads in life, planning your future, or simply want
                to better understand yourself, identifying your core values provides a compass
                for decision-making and personal growth.
              </p>
            </div>
          </section>

          <section aria-labelledby="how-it-works-heading">
            <h2 id="how-it-works-heading" className="text-2xl font-bold text-gray-900">
              How It Works
            </h2>
            <div
              className="grid gap-4 md:grid-cols-3"
              role="list"
            >
              {[
                {
                  title: "1. Explore",
                  description: "Browse through carefully curated value cards and begin sorting them based on their importance to you."
                },
                {
                  title: "2. prioritise",
                  description: "Organize values into categories, helping you identify which ones resonate most strongly with your personal beliefs."
                },
                {
                  title: "3. Reflect",
                  description: "Review your choices and gain insights into what truly matters to you, helping guide future decisions."
                }
              ].map((step, index) => (
                <div
                  key={step.title}
                  className="bg-white p-6 rounded-lg shadow-sm border border-gray-100"
                  role="listitem"
                >
                  <div className="text-blue-600 text-xl mb-2">{step.title}</div>
                  <p className="text-gray-600">{step.description}</p>
                </div>
              ))}
            </div>
          </section>

          <section aria-labelledby="benefits-heading">
            <h2 id="benefits-heading" className="text-2xl font-bold text-gray-900">
              Benefits
            </h2>
            <div
              className="grid gap-4 md:grid-cols-2"
              role="list"
            >
              {[
                {
                  icon: "🎯",
                  title: "Clear Decision Making",
                  description: "Use your identified values as a framework for making choices that align with what truly matters to you."
                },
                {
                  icon: "🧭",
                  title: "Personal Growth",
                  description: "Gain deeper self-awareness and understanding of your motivations and priorities."
                },
                {
                  icon: "🤝",
                  title: "Better Relationships",
                  description: "Communicate your values clearly to others and understand what drives your interactions."
                },
                {
                  icon: "⚡",
                  title: "Increased Motivation",
                  description: "Align your goals with your values for more meaningful and sustainable motivation."
                }
              ].map((benefit) => (
                <div
                  key={benefit.title}
                  className="bg-gray-50 p-4 rounded-lg"
                  role="listitem"
                >
                  <h3 className="font-semibold text-gray-900 mb-2">
                    <span aria-hidden="true">{benefit.icon} </span>
                    {benefit.title}
                  </h3>
                  <p className="text-gray-600">{benefit.description}</p>
                </div>
              ))}
            </div>
          </section>

          <section aria-labelledby="privacy-heading">
            <h2 id="privacy-heading" className="text-2xl font-bold text-gray-900">
              Your Data & Privacy
            </h2>
            <div
              className="space-y-4"
              role="list"
            >
              {[
                {
                  icon: "📱",
                  title: "Private & Local Storage",
                  description: "All your selections and progress are stored directly on your device. Think of it like having a personal notebook that only exists on your phone or computer.",
                  bgColor: "bg-blue-50",
                  textColor: "text-blue-900"
                },
                {
                  icon: "🔒",
                  title: "Complete Privacy",
                  description: "Your data never leaves your device - we do not use any external servers or cloud storage. Your personal journey stays completely private.",
                  bgColor: "bg-green-50",
                  textColor: "text-green-900"
                },
                {
                  icon: "💾",
                  title: "Automatic Saving",
                  description: "Every change you make is automatically saved on your device. You can close the app and come back later - your progress will be waiting for you.",
                  bgColor: "bg-purple-50",
                  textColor: "text-purple-900"
                },
                {
                  icon: "⚡",
                  title: "Works Offline",
                  description: "Because everything is stored on your device, you can use the app even without an internet connection. Perfect for deep reflection anywhere.",
                  bgColor: "bg-yellow-50",
                  textColor: "text-yellow-900"
                }
              ].map((item) => (
                <div
                  key={item.title}
                  className={`${item.bgColor} p-4 rounded-lg`}
                  role="listitem"
                >
                  <h3 className={`font-semibold ${item.textColor} mb-2`}>
                    <span aria-hidden="true">{item.icon} </span>
                    {item.title}
                  </h3>
                  <p className="text-gray-600">{item.description}</p>
                </div>
              ))}
            </div>
          </section>

          <section aria-labelledby="notes-heading">
            <h2 id="notes-heading" className="sr-only">Important Notes</h2>
            <div className="space-y-4">
              <div
                className="bg-red-50 p-4 rounded-lg"
                role="alert"
              >
                <h3 className="font-semibold text-red-900 mb-2">
                  <span aria-hidden="true">⚠️ </span>
                  Important Note
                </h3>
                <p className="text-gray-600">
                  If you clear your browser data or uninstall the app, your stored
                  information will be deleted. Consider taking screenshots or noting down
                  important results if you want to keep them long-term.
                </p>
              </div>

              <div className="bg-gray-50 p-4 rounded-lg">
                <h3 className="font-semibold text-gray-900 mb-2">
                  <span aria-hidden="true">💡 </span>
                  Pro Tip
                </h3>
                <p className="text-gray-600">
                  For the best experience, install this as an app on your device
                  (look for the Install App button in your browser). This makes it easier
                  to access and use, just like any other app on your device!
                </p>
              </div>
            </div>
          </section>
          <section aria-labelledby="instructions-heading">
            <h2 id="instructions-heading" className="text-2xl font-bold text-gray-900">
              Instructions Preference
            </h2>
            <div
              className="bg-gray-50 p-4 rounded-lg"
              role="group"
              aria-labelledby="instructions-heading"
            >
              <div
                className="flex items-center gap-3"
                role="group"
                aria-labelledby="instructions-label"
              >
                <div className="relative flex items-start">
                  <div className="flex items-center h-5">
                    <input
                      type="checkbox"
                      id="show-instructions"
                      checked={showInstructions}
                      onChange={handleToggleInstructions}
                      className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                      aria-describedby="instructions-description"
                      aria-checked={showInstructions}
                    />
                  </div>
                  <div className="ml-3 text-sm">
                    <label
                      id="instructions-label"
                      htmlFor="show-instructions"
                      className="font-medium text-gray-900"
                    >
                      Show instructions when starting the exercise
                    </label>
                    <p
                      id="instructions-description"
                      className="text-gray-600 mt-2"
                    >
                      <span className="sr-only">
                        Current status:
                      </span>
                      {showInstructions
                        ? "Instructions will be shown when you start a new exercise."
                        : "Instructions are currently hidden. Enable this to see them again."}
                    </p>
                  </div>
                </div>
              </div>

              <div
                className="mt-4 text-sm text-gray-500"
                role="status"
                aria-live="polite"
              >
                <span className="sr-only">Preference saved: </span>
                {showInstructions
                  ? "Instructions will appear at the start of each new exercise"
                  : "Instructions will not appear automatically. You can change this setting at any time"}
              </div>
            </div>
          </section>

        </div>
      </div>
    </div>
  );
}

================
File: src/app/error.tsx
================
// src/app/error.tsx
'use client'

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log error for debugging but ensure no sensitive info is exposed
    console.error('App Error:', {
      message: error.message,
      digest: error.digest,
      name: error.name
    })
  }, [error])

  return (
    <main 
      className="flex-1 flex items-center justify-center p-4"
      role="alert"
      aria-labelledby="error-heading"
    >
      <div className="text-center max-w-md">
        <h1 
          id="error-heading"
          className="text-2xl font-bold mb-4"
        >
          Something went wrong!
        </h1>
        
        <div className="mb-6">
          <p 
            className="text-gray-600 mb-2"
            aria-live="polite"
          >
            We encountered an unexpected error. 
            You can try again or return to the home page.
          </p>
          {process.env.NODE_ENV === 'development' && error.message && (
            <p 
              className="text-red-600 text-sm mt-2"
              aria-label="Error details"
            >
              {error.message}
            </p>
          )}
        </div>

        <div className="space-y-4">
          <button
            onClick={() => reset()}
            className="w-full px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors"
            aria-label="Attempt to recover from error"
          >
            Try again
          </button>
          
          {error.digest && (
            <p 
              className="text-xs text-gray-500"
              aria-label="Error reference code"
            >
              Error Reference: {error.digest}
            </p>
          )}
        </div>
      </div>
    </main>
  )
}

================
File: src/app/history/page.tsx
================
// src/app/history/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { Session } from "@/lib/types";
import { getSessions } from "@/lib/db/indexedDB";
import { SessionList } from "@/components/features/History/components/SessionList";
export default function HistoryPage() {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    const loadSessions = async () => {
      try {
        const allSessions = await getSessions();
        setSessions(allSessions.sort((a, b) => b.timestamp - a.timestamp));
      } catch (error) {
        console.error('Failed to load sessions:', error);
      } finally {
        setIsLoading(false);
      }
    };
    loadSessions();
  }, []);
  return <div className="flex-1 overflow-y-auto">
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-6">Session History</h1>
        
        <section aria-label="Value sorting sessions history" className="space-y-4">
        {isLoading ? <div role="status" aria-live="polite" className="text-center py-4">
            <span className="sr-only">Loading session history...</span>
            Loading...
          </div> : sessions.length === 0 ? <p role="status" aria-live="polite" className="text-gray-600 text-center py-4">
            No sessions found. Complete a value sorting exercise to see your history.
          </p> : <SessionList sessions={sessions} aria-label="List of completed value sorting sessions" />}
      </section>
    </div>
    </div>;
}

================
File: src/app/layout.tsx
================
// layout.tsx
'use client';

import '@/styles/globals.css';
import Navigation from "@/components/common/Navigation";
import { MobileProvider } from "@/lib/contexts/MobileContext";
export default function RootLayout({
  children
}: {
  children: React.ReactNode;
}) {
  return <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
        <meta name="theme-color" content="#3b82f6" />
        <link rel="manifest" href="/manifest.webmanifest" type="application/manifest+json" />
        <link rel="icon" href="/favicon.ico" />
        <link rel="apple-touch-icon" href="/icons/icon-192x192.png" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="default" />
        <meta name="format-detection" content="telephone=no" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="msapplication-tap-highlight" content="no" />
        <meta name="msapplication-TileColor" content="#3b82f6" />
        <title>Core Values</title>
        <meta name="description" content="Discover and prioritise your personal values" />
        {process.env.NODE_ENV === 'development' && <meta httpEquiv="Cache-Control" content="no-cache, no-store, must-revalidate" />}
      </head>
      <body className="bg-gray-50">
        <MobileProvider>
          <div className="min-h-screen flex flex-col">
            {/* Header */}
            <header className="bg-blue-500 text-white shadow-md flex-shrink-0" role="banner" aria-label="Site header">
              <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <Navigation />
              </div>
            </header>

            {/* Main content */}
            <main className="flex-1 flex flex-col md:overflow-hidden" // Only hide overflow on desktop
          role="main" aria-label="Main content">
              {children}
              <div id="portal-root" />
            </main>

            {/* Footer */}
            <footer className="bg-blue-500 text-white md:flex-shrink-0" // Only shrink on desktop
          role="contentinfo" aria-label="Site footer">
              <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
                <p className="text-center text-white/90 text-sm">
                  © {new Date().getFullYear()} Core Values App
                </p>
              </div>
            </footer>
          </div>
        </MobileProvider>
      </body>
    </html>;
}

================
File: src/app/not-found.tsx
================
// src/app/not-found.tsx
'use client'

import Link from 'next/link';

export default function NotFound() {
  return (
    <div 
      className="flex-1 flex items-center justify-center p-4"
      role="main"
    >      <div 
        className="text-center"
        role="alert"
        aria-labelledby="not-found-title"
      >
        <h1 
          id="not-found-title"
          className="text-2xl font-bold mb-4"
        >
          Page Not Found
        </h1>
        <p 
          className="mb-4 text-gray-600"
          aria-live="polite"
        >
          Could not find requested resource
        </p>
        <Link 
          href="/"
          className="text-blue-600 hover:text-blue-800 underline inline-flex items-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded px-2 py-1"
          aria-label="Return to homepage"
        >
          <span aria-hidden="true">←</span>
          <span className="ml-1">Return Home</span>
        </Link>
      </div>
    </div>
  );
}

================
File: src/app/page.tsx
================
// src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import RoundUIDebug from "@/components/features/Round/RoundUIDebug";
import StartScreen from "@/components/features/Game/components/StartScreen";
import RoundUI from "@/components/features/Round/RoundUI";
import Instructions from "@/components/common/Instructions";
import { initDB } from "@/lib/db/indexedDB";
import valuesData from "@/data/values.json";
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { usePWA } from "@/lib/hooks/usePWA";
import PWAPrompt from "@/components/common/PWAPrompt";
import { cacheUtils } from "@/lib/utils/storage";
import { useSession } from "@/components/features/Game/hooks/useSession";
import { useGameState } from "@/components/features/Game/hooks/useGameState";
import { clearGameState } from "@/lib/utils/storage";
import { forceReload } from "@/lib/utils/cache";
export default function Home() {
  const [isLoading, setIsLoading] = useState(true);
  const {
    sessionId
  } = useSession();
  const {
    isGameStarted,
    showInstructions,
    setGameStarted,
    setShowInstructions
  } = useGameState();
  const {
    isOffline
  } = usePWA();
  useEffect(() => {
    const lastVersion = localStorage.getItem('app-version');
    const currentVersion = process.env.NEXT_PUBLIC_VERSION ?? '0.0.0';
    if (lastVersion !== currentVersion) {
      localStorage.setItem('app-version', currentVersion);
      forceReload();
    }
  }, []);
  useEffect(() => {
    if (!window.location.search.includes('sessionId')) {
      clearGameState();
    }
    setIsLoading(false);
  }, []);
  useEffect(() => {
    const initialize = async () => {
      try {
        await initDB();
        if (!sessionId && isOffline) {
          const cachedSession = await cacheUtils.getCachedData<{
            sessionId: string;
            values: typeof valuesData.values;
          }>('currentSession');
          if (cachedSession) {
            setGameStarted(true);
          }
        }
      } catch (error) {
        console.error('Error loading cached data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    initialize();
  }, [isOffline, sessionId, setGameStarted]);
  const handleGameStart = () => {
    setGameStarted(true);
    setShowInstructions(true);
  };
  if (isLoading) {
    return <div className="flex items-center justify-center flex-1" role="status" aria-live="polite">
        <span className="sr-only">Loading application...</span>
        Loading...
      </div>;
  }

  // Use RoundUIDebug in development, RoundUI in production
  const GameComponent = process.env.NODE_ENV === 'development' ? RoundUIDebug : RoundUI;
  return <DndProvider backend={HTML5Backend}>
      <div className="flex-1 flex flex-col" aria-label="Core Values Application">
        <h1 className="sr-only">Core Values - Personal Value Discovery Tool</h1>
        
        {!isGameStarted ? <StartScreen onStart={handleGameStart} /> : <GameComponent />}
        
        {showInstructions && <Instructions onClose={() => setShowInstructions(false)} onStart={handleGameStart} aria-label="Game Instructions" />}
        
        <PWAPrompt />
      </div>
    </DndProvider>;
}

================
File: src/app/replay/page.tsx
================
// src/app/replay/page.tsx
'use client';

import { Suspense } from 'react';
import ReplayClient from "@/components/features/Replay/components/ReplayClient";
export default function ReplayPage() {
  return <div className="flex-1">
      <Suspense fallback={<div role="status" aria-live="polite" className="flex items-center justify-center h-full">
            <span className="sr-only">Loading session replay...</span>
            <div className="text-gray-600">Loading...</div>
          </div>}>
        <section className="h-full" aria-label="Session Replay">
          <h1 className="sr-only">Core Values Session Replay</h1>
          <ReplayClient />
        </section>
      </Suspense>
    </div>;
}

================
File: src/components/common/CentredImage/index.tsx
================
// src/components/CentredImage.tsx
export default function CenteredImage() {
  return (
    <div className="absolute inset-0">
      <img
        src="/images/core-values.png" // Update with your actual image path
        alt="Core Values"
        className="w-full h-full object-cover"
      />
    </div>
  );
}

================
File: src/components/common/Instructions/index.tsx
================
'use client'

import { useState, useCallback, useEffect } from 'react';
import { InstructionsProps } from './types';

export default function Instructions({ onClose }: InstructionsProps) {
  const [shouldShowAgain, setShouldShowAgain] = useState(true);

  useEffect(() => {
    const savedPreference = localStorage.getItem('showInstructions');
    if (savedPreference === 'false') {
      onClose();
    }
  }, [onClose]);

  const handleClose = useCallback(() => {
    if (!shouldShowAgain) {
      localStorage.setItem('showInstructions', 'false');
    }
    onClose();
  }, [shouldShowAgain, onClose]);

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-2 sm:p-4 z-50">
      <div className="bg-white p-4 sm:p-6 rounded-lg max-w-xs sm:max-w-sm md:max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <h2 className="text-xl sm:text-2xl font-bold mb-3 sm:mb-4">How to Use Core Values</h2>
        <ol className="list-decimal ml-4 sm:ml-6 space-y-1 sm:space-y-2 text-sm sm:text-base">
          <li>You have already entered the number of core values you want to end up with (typically 5).</li>
          <li>For each round, you&apos;ll see value cards that you need to sort into categories.</li>
          <li>Drag each card into one of the five categories based on its importance to you: Very Important, Quite Important, Important, Of Some Importance or Not Important</li>
          <li>Click on a card&apos;s title to show/hide its description.</li>
          <li>Use the up/down arrows to reorder cards within a category.</li>
          <li>When you&apos;re done sorting all cards, click &quot;Next Round&quot;.</li>
          <li>In the next round, cards marked as &quot;Not Important&quot; will be removed.</li>
          <li>Continue sorting until you reach your target number of core values.</li>
          <li>Then tell me why you chose your values.</li>
        </ol>

        <div className="mt-4 sm:mt-6 space-y-4">
          <label className="flex items-center gap-2 text-gray-600">
            <input
              type="checkbox"
              checked={!shouldShowAgain}
              onChange={(e) => setShouldShowAgain(!e.target.checked)}
              className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
            />
            <span className="text-sm">Don&apos;t show these instructions again</span>
          </label>

          <button
            onClick={handleClose}
            className="w-full sm:w-auto px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
          >
            Got it!
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/common/Instructions/types.ts
================
'use client';
export interface InstructionsProps {
  onStart?: () => void;
  onClose: () => void;
}

================
File: src/components/common/Navigation/index.tsx
================
// src/components/Navigation.tsx
import { useState } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';

export default function Navigation() {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const pathname = usePathname();
  const getActiveClass = (path: string) => {
    return pathname === path 
      ? 'bg-white text-blue-600 font-semibold rounded-md' 
      : 'text-white hover:bg-white/20 rounded-md transition-colors';
  };

  return (
    <nav 
      className="flex items-center justify-between px-4 py-2"
      role="navigation"
      aria-label="Main navigation"
    >
      <Link 
        href="/" 
        className="text-xl font-bold text-white"
        aria-label="Core Values Home"
      >
        Core Values
      </Link>

      {/* Desktop Navigation */}
      <div 
        className="hidden md:flex space-x-4"
        role="menubar"
        aria-label="Desktop navigation"
      >
        <Link 
          href="/" 
          className={`${getActiveClass('/')} text-lg px-4 py-2`}
          role="menuitem"
        >
          Home
        </Link>
        <Link 
          href="/about" 
          className={`${getActiveClass('/about')} text-lg px-4 py-2`}
          role="menuitem"
        >
          About
        </Link>
        <Link 
          href="/history" 
          className={`${getActiveClass('/history')} text-lg px-4 py-2`}
          role="menuitem"
        >
          History
        </Link>
      </div>

      {/* Mobile Navigation */}
      <div className="md:hidden">
        <button 
          onClick={() => setIsMenuOpen(!isMenuOpen)}
          className="text-white p-2"
          aria-label="Toggle menu"
          aria-expanded={isMenuOpen}
          aria-controls="mobile-menu"
        >
          <svg 
            className="w-6 h-6" 
            fill="none" 
            strokeLinecap="round" 
            strokeLinejoin="round" 
            strokeWidth="2" 
            viewBox="0 0 24 24" 
            stroke="currentColor"
            aria-hidden="true"
          >
            <path d="M4 6h16M4 12h16M4 18h16"></path>
          </svg>
        </button>

        {/* Mobile Menu Dropdown */}
        {isMenuOpen && (
          <div 
            id="mobile-menu"
            className="absolute top-14 right-4 bg-white shadow-lg rounded-lg py-2 z-50"
            role="menu"
            aria-label="Mobile navigation"
          >
            <Link 
              href="/" 
              className="block px-4 py-2 text-gray-800 hover:bg-gray-100"
              onClick={() => setIsMenuOpen(false)}
              role="menuitem"
            >
              Home
            </Link>
            <Link 
              href="/about" 
              className="block px-4 py-2 text-gray-800 hover:bg-gray-100"
              onClick={() => setIsMenuOpen(false)}
              role="menuitem"
            >
              About
            </Link>
            <Link 
              href="/history" 
              className="block px-4 py-2 text-gray-800 hover:bg-gray-100"
              onClick={() => setIsMenuOpen(false)}
              role="menuitem"
            >
              History
            </Link>
          </div>
        )}
      </div>
    </nav>
  );
}

================
File: src/components/common/OfflineIndicator/index.tsx
================
// src/components/OfflineIndicator.tsx
'use client';

import { usePWA } from "@/lib/hooks/usePWA";
export default function OfflineIndicator() {
  const {
    isOffline
  } = usePWA();
  if (!isOffline) return null;
  return <div role="alert" aria-live="polite" className="fixed bottom-2 sm:bottom-4 left-2 sm:left-4 transform transition-all duration-300 
                bg-yellow-500 text-white px-3 sm:px-4 py-2 sm:py-3 
                text-xs sm:text-sm rounded-lg shadow-lg z-50 
                max-w-[calc(100vw-1rem)] sm:max-w-md">
      <div className="flex items-center space-x-2" aria-label="Offline status indicator">
        <span className="h-2 w-2 bg-white rounded-full animate-pulse" aria-hidden="true" />
        <span className="sr-only">Warning:</span>
        <span>You are offline. Some features may be limited.</span>
      </div>
    </div>;
}

================
File: src/components/common/PWAPrompt/index.tsx
================
// src/components/PWAPrompt.tsx
'use client';

import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { usePWA } from "@/lib/hooks/usePWA";
type PromptType = 'install' | 'update' | null;
export default function PWAPrompt() {
  const [showPrompt, setShowPrompt] = useState(false);
  const [promptType, setPromptType] = useState<PromptType>(null);
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const {
    needsUpdate,
    updateServiceWorker
  } = usePWA();
  useEffect(() => {
    // Handle installation prompt
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e);
      // Only show install prompt if there's no update needed
      if (!needsUpdate) {
        setPromptType('install');
        setShowPrompt(true);
      }
    };

    // Handle update availability
    if (needsUpdate) {
      setPromptType('update');
      setShowPrompt(true);
    }
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);

    // Hide prompts if app is already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setShowPrompt(false);
    }
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    };
  }, [needsUpdate]);
  const handleInstallClick = async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const {
      outcome
    } = await deferredPrompt.userChoice;
    setDeferredPrompt(null);
    setShowPrompt(false);
    if (outcome === 'accepted') {
      console.log('User accepted the install prompt');
    } else {
      console.log('User dismissed the install prompt');
    }
  };
  const handleUpdateClick = async () => {
    await updateServiceWorker();
    setShowPrompt(false);
  };
  const handleDismiss = () => {
    setShowPrompt(false);
    if (promptType === 'install') {
      localStorage.setItem('pwa-prompt-dismissed', 'true');
    }
  };

  // Don't render anything in development
  if (process.env.NODE_ENV === 'development') {
    return null;
  }
  if (!showPrompt) return null;
  const promptTitle = promptType === 'install' ? 'Install Core Values App' : 'Update Available';
  const promptDescription = promptType === 'install' ? 'Install our app for a better experience with offline access and faster loading times.' : 'A new version is available. Update now for the latest features and improvements.';
  return <AnimatePresence>
      {showPrompt && <motion.div role="alertdialog" aria-labelledby="pwa-prompt-title" aria-describedby="pwa-prompt-description" initial={{
      opacity: 0,
      y: 0
    }} animate={{
      opacity: 1,
      y: 0
    }} exit={{
      opacity: 0,
      y: 0
    }} className="fixed bottom-4 left-1/2 transform -translate-x-1/2 w-11/12 sm:w-96 bg-white rounded-lg shadow-lg p-4 border border-gray-200 z-50">
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <h2 id="pwa-prompt-title" className="text-base font-semibold text-gray-900">
                {promptTitle}
              </h2>
              <p id="pwa-prompt-description" className="mt-1 text-sm text-gray-500">
                {promptDescription}
              </p>
              <div className="mt-4 flex space-x-3" role="group" aria-label="PWA prompt actions">
                <button onClick={promptType === 'install' ? handleInstallClick : handleUpdateClick} className="flex-1 bg-blue-600 text-white px-4 py-2 text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" aria-label={promptType === 'install' ? 'Install application' : 'Update application'}>
                  {promptType === 'install' ? 'Install' : 'Update Now'}
                </button>
                {promptType === 'install' && <button onClick={handleDismiss} className="flex-1 bg-white text-gray-700 px-4 py-2 text-sm font-medium border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" aria-label="Dismiss installation prompt">
                    Not Now
                  </button>}
              </div>
            </div>
          </div>
        </motion.div>}
    </AnimatePresence>;
}

================
File: src/components/features/Cards/components/AnimatedCard.tsx
================
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import type { CardProps } from '@/components/features/Cards/types';
import { getEnvBoolean } from "@/lib/utils/config";
import { CardControls } from './CardControls';
import { CardMoveOptions } from './CardMoveOptions';
import { CardContent } from './CardContent';
import { getPostItStyles } from './styles';

// Faster animation settings for replay
const cardVariants = {
  initial: {
    scale: 0.8,
    opacity: 0
  },
  animate: {
    scale: 1,
    opacity: 1
  },
  exit: {
    scale: 0.8,
    opacity: 0
  },
  hover: {
    scale: 1.05
  }
};
const cardTransition = {
  type: "spring",
  stiffness: 700,
  // Increased from 500
  damping: 30,
  // Reduced from 35
  mass: 0.8 // Reduced from 1
};

// This version uses Framer Motion for Replay view
export function AnimatedCard({
  value,
  onMoveUp,
  onMoveDown,
  onMoveBetweenCategories,
  currentCategory,
  columnIndex
}: CardProps) {
  const debug = getEnvBoolean('debug', false);
  const [isExpanded, setIsExpanded] = useState(false);
  const [showMoveOptions, setShowMoveOptions] = useState(false);
  if (!value) return null;
  const isInCategory = columnIndex !== undefined;
  const {
    postItBaseStyles,
    tapeEffect
  } = getPostItStyles(false, false);
  if (isInCategory) {
    return <motion.div id={`card-${value.title}`} variants={cardVariants} initial="initial" animate="animate" exit="exit" whileHover="hover" transition={cardTransition} className={`${postItBaseStyles} ${tapeEffect} w-full min-h-[40px] relative`}>
        <CardContent title={value.title} description={value.description} isExpanded={isExpanded} controls={<CardControls onMoveUp={onMoveUp} onMoveDown={onMoveDown} onShowMoveOptions={() => setShowMoveOptions(!showMoveOptions)} currentCategory={currentCategory} isExpanded={isExpanded} onToggleExpand={() => setIsExpanded(!isExpanded)} value={value} // Add this
      />} />
        <AnimatePresence>
          {showMoveOptions && onMoveBetweenCategories && currentCategory && <div className="relative z-50">
              <CardMoveOptions value={value} currentCategory={currentCategory} onMoveBetweenCategories={onMoveBetweenCategories} onClose={() => setShowMoveOptions(false)} />
            </div>}
        </AnimatePresence>
      </motion.div>;
  }
  return <motion.div variants={cardVariants} initial="initial" animate="animate" exit="exit" whileHover="hover" transition={cardTransition} className={`${postItBaseStyles} ${tapeEffect} w-full sm:w-48 h-auto sm:h-48 max-w-sm mx-auto p-3 sm:p-4`}>
      <div className="relative z-10">
        <h3 className="font-medium text-gray-800 text-sm sm:text-base mb-2 sm:mb-3">{value.title}</h3>
        <p className="text-xs sm:text-sm text-gray-700 leading-relaxed">{value.description}</p>
      </div>
    </motion.div>;
}

================
File: src/components/features/Cards/components/Card.tsx
================
'use client';

import { memo, useRef, useState } from 'react';
import type { CardProps, DroppedValue } from '@/components/features/Cards/types';
import { getEnvBoolean } from "@/lib/utils/config";
import { CardControls } from './CardControls';
import { CardMoveOptions } from './CardMoveOptions';
import { CardContent } from './CardContent';
import { getPostItStyles } from './styles';
import { CategoryName, Value } from "@/lib/types";
import { useMobile } from "@/lib/contexts/MobileContext";


const Card = memo(function Card({
  value,
  onDrop,
  onMoveUp,
  onMoveDown,
  onMoveBetweenCategories,
  currentCategory,
  columnIndex,
  onClick,
  selectedMobileCard
}: CardProps) {
  const debug = getEnvBoolean('debug', false);
  const [isDragging, setIsDragging] = useState(false);
  const [isOver, setIsOver] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);
  const [showMoveOptions, setShowMoveOptions] = useState(false);
  const draggedIndexRef = useRef<number | null>(null);
  const {
    isMobile
  } = useMobile();
  if (!value) return null;
  const isInCategory = columnIndex !== undefined;
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>): void => {
    if (isMobile) {
      e.preventDefault();
      return;
    }
    setIsDragging(true);
    draggedIndexRef.current = columnIndex !== undefined ? columnIndex : null;
    const dragData = {
      id: value.id,
      title: value.title,
      description: value.description,
      sourceCategory: currentCategory,
      sourceIndex: columnIndex,
      isInternalDrag: isInCategory
    };
    e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
    e.dataTransfer.effectAllowed = 'move';
    if (debug) console.log('🎪 Card dragStart:', dragData);
  };
  const handleDragOver = (e: React.DragEvent<HTMLDivElement>): void => {
    if (isMobile) return;
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
    setIsOver(true);
  };
  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    if (isMobile) return;
    e.preventDefault();
    e.stopPropagation();
    setIsOver(false);
    try {
      const droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
      const sourceIndex = droppedData.sourceIndex;
      const targetIndex = columnIndex;
      const sourceCategory = droppedData.sourceCategory;
      if (debug) {
        console.log('📥 Drop data:', {
          droppedData,
          sourceIndex,
          targetIndex,
          sourceCategory,
          currentCategory
        });
      }

      // Handle internal category reordering
      if (droppedData.isInternalDrag && sourceCategory === currentCategory && sourceIndex !== undefined && targetIndex !== undefined) {
        if (sourceIndex < targetIndex) {
          onMoveDown?.();
        } else if (sourceIndex > targetIndex) {
          onMoveUp?.();
        }
      }
      // Handle between category movement
      else if (sourceCategory && currentCategory && sourceCategory !== currentCategory) {
        onMoveBetweenCategories?.({
          id: droppedData.id,
          title: droppedData.title,
          description: droppedData.description
        }, sourceCategory, currentCategory);
      }
      // Handle new card drop
      else if (onDrop) {
        onDrop(droppedData);
      }
    } catch (error) {
      console.error('Error handling drop:', error);
    }
  };
  const handleDragEnd = (): void => {
    if (isMobile) return;
    setIsDragging(false);
    setIsOver(false);
    draggedIndexRef.current = null;
    if (debug) console.log('🏁 Card dragEnd:', {
      value,
      columnIndex
    });
  };
  const handleDragEnter = (e: React.DragEvent<HTMLDivElement>): void => {
    if (isMobile) return;
    e.preventDefault();
    e.stopPropagation();
    setIsOver(true);
  };
  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>): void => {
    if (isMobile) return;
    e.preventDefault();
    e.stopPropagation();
    setIsOver(false);
  };
  const handleCardClick = () => {
    if (isMobile && onClick) {
      onClick(value);
    }
  };
  const {
    postItBaseStyles,
    tapeEffect
  } = getPostItStyles(isDragging, isOver);
  const cardContainerClasses = `
    ${postItBaseStyles} 
    ${tapeEffect} 
    ${isInCategory ? 'w-full max-w-full min-h-[40px]' : 'w-48 h-48'}
    relative select-none cursor-move
    ${isMobile ? 'touch-manipulation' : ''}
    ${isOver ? 'border-2 border-blue-300' : ''}
    ${isMobile && onClick && !isInCategory ? 'hover:bg-yellow-50 active:bg-yellow-200' : ''}
    ${selectedMobileCard ? 'bg-yellow-200' : ''} // Add this for selected state
`;
  if (isInCategory) {
    return (
      <div
        id={`card-${value.id}`}
        data-index={columnIndex}
        data-dropzone="true"
        draggable="true"
        onClick={handleCardClick}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        className={`${cardContainerClasses} group`}
        role="article"
        aria-label={`Value card: ${value.title}`}
        tabIndex={0}
        onKeyPress={e => {
          if (e.key === 'Enter' || e.key === ' ') {
            handleCardClick();
          }
        }}
      >
        <div className="relative flex">
          <div className="flex-1 pr-10">
            <CardContent
              title={value.title}
              description={value.description}
              isExpanded={isExpanded}
              controls={!isMobile ? (
                <div className="absolute -right-2 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                  <CardControls
                    onMoveUp={onMoveUp}
                    onMoveDown={onMoveDown}
                    onShowMoveOptions={() => setShowMoveOptions(!showMoveOptions)}
                    currentCategory={currentCategory}
                    isExpanded={isExpanded}
                    onToggleExpand={() => setIsExpanded(!isExpanded)}
                    value={value}
                  />
                </div>
              ) : null}
            />
          </div>
        </div>
        {!isMobile && showMoveOptions && onMoveBetweenCategories && currentCategory && (
          <div className="absolute right-2 top-8 z-50" role="dialog" aria-label="Move options">
            <CardMoveOptions
              value={value}
              currentCategory={currentCategory}
              onMoveBetweenCategories={onMoveBetweenCategories}
              onClose={() => setShowMoveOptions(false)}
            />
          </div>
        )}
      </div>
    );
  }
  return <div draggable="true" onClick={handleCardClick} onDragStart={handleDragStart} onDragEnd={handleDragEnd} onDragEnter={handleDragEnter} onDragLeave={handleDragLeave} onDragOver={handleDragOver} onDrop={handleDrop} className={cardContainerClasses} role="article" aria-label={`Value card: ${value.title}`} tabIndex={0} onKeyPress={e => {
    if (e.key === 'Enter' || e.key === ' ') {
      handleCardClick();
    }
  }}>
    <div className="relative z-10 pointer-events-none" role="region" aria-label={`Content for ${value.title}`}>
      <h3 className="font-medium text-gray-800 mb-3">{value.title}</h3>
      <p className="text-sm text-gray-700 leading-relaxed">{value.description}</p>
    </div>
  </div>;
});
export default Card;

================
File: src/components/features/Cards/components/CardContent.tsx
================
// src/components/Card/CardContent.tsx
import { motion, AnimatePresence } from 'framer-motion';
import { CardContentProps } from '@/components/features/Cards/types';

export function CardContent({
  title,
  description,
  isExpanded,
  controls
}: Omit<CardContentProps, 'onToggle'> & { controls?: React.ReactNode }) {
  const headingId = `heading-${title.toLowerCase().replace(/\s+/g, '-')}`;
  const descriptionId = `description-${title.toLowerCase().replace(/\s+/g, '-')}`;

  return (
    <div
      className="flex flex-col w-full p-2"
      role="region"
      aria-labelledby={headingId}
    >
      <div
        className="flex items-start justify-between gap-2 w-full"
        role="heading"
        aria-level={3}
      >
        <h3
          id={headingId}
          className="font-medium text-gray-800 text-sm sm:text-base flex-1 break-words pr-2"
        >
          {title}
        </h3>

        {controls && (
          <div
            className="flex-shrink-0 ml-auto pointer-events-auto" // Add pointer-events-auto here
            role="toolbar"
            aria-label={`Controls for ${title}`}
          >
            {controls}
          </div>
        )}
      </div>

      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.2 }}
            className="mt-2 border-t border-gray-100 pt-2"
            role="region"
            aria-labelledby={descriptionId}
          >
            <p
              id={descriptionId}
              className="px-4 pb-3 text-base text-gray-800 leading-relaxed"
              aria-expanded={isExpanded}
            >
              <span className="sr-only">Description: </span>
              {description}
            </p>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

================
File: src/components/features/Cards/components/CardControls.tsx
================
// src/components/Card/CardControls.tsx
import { TouchEvent as ReactTouchEvent, MouseEvent as ReactMouseEvent } from 'react';
import { Value } from "@/lib/types";
import { ExtendedCardControlsProps } from '@/components/features/Cards/types';

export function CardControls({
  onMoveUp,
  onMoveDown,
  onShowMoveOptions,
  currentCategory,
  isExpanded,
  onToggleExpand,
  value
}: ExtendedCardControlsProps) {
  const handleButtonClick = (e: ReactMouseEvent<HTMLButtonElement> | ReactTouchEvent<HTMLButtonElement>, action: () => void) => {
    e.stopPropagation();
    e.preventDefault();
    action();
  };
  const buttonBaseClass = `
    p-1.5 text-gray-600 hover:text-gray-900 rounded text-sm 
    hover:bg-gray-100 active:bg-gray-200 transition-colors touch-none select-none
    focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1
  `;
  return <div className="flex gap-0 items-center justify-end min-w-[120px] ml-auto pointer-events-auto" // Add pointer-events-auto here
  role="toolbar" aria-label={`Controls for ${value.title}`} onTouchStart={(e: ReactTouchEvent) => e.stopPropagation()} onClick={(e: ReactMouseEvent) => e.stopPropagation()}>
      <div role="group" aria-label="Card actions">
        <button type="button" onClick={e => handleButtonClick(e, () => onToggleExpand?.())} onTouchStart={e => handleButtonClick(e, () => onToggleExpand?.())} className={buttonBaseClass} aria-label={`${isExpanded ? 'Collapse' : 'Expand'} card details`} aria-expanded={isExpanded} aria-controls={`description-${value.id}`}>
          <span className="inline-block w-4 text-center" aria-hidden="true">
            {isExpanded ? '▼' : '▶︎'}
          </span>
        </button>

        {onMoveUp && <button type="button" onClick={e => handleButtonClick(e, onMoveUp)} onTouchStart={e => handleButtonClick(e, onMoveUp)} className={buttonBaseClass} aria-label={`Move ${value.title} up in ${currentCategory}`}>
            <span className="inline-block w-4 text-center" aria-hidden="true">
              ↑
            </span>
          </button>}

        {onMoveDown && <button type="button" onClick={e => handleButtonClick(e, onMoveDown)} onTouchStart={e => handleButtonClick(e, onMoveDown)} className={buttonBaseClass} aria-label={`Move ${value.title} down in ${currentCategory}`}>
            <span className="inline-block w-4 text-center" aria-hidden="true">
              ↓
            </span>
          </button>}

        {currentCategory && <button type="button" id={`options-${value.id}`} onClick={e => handleButtonClick(e, onShowMoveOptions)} onTouchStart={e => handleButtonClick(e, onShowMoveOptions)} className={buttonBaseClass} aria-label={`Show move options for ${value.title}`} aria-haspopup="true">
            <span className="inline-block w-4 text-center" aria-hidden="true">
              ⋮
            </span>
          </button>}
      </div>
    </div>;
}

================
File: src/components/features/Cards/components/CardMoveOptions.tsx
================
// src/components/Card/CardMoveOptions.tsx
import { motion } from 'framer-motion';
import { createPortal } from 'react-dom';
import { useEffect, useState, useCallback } from 'react';
import { CardMoveOptionsProps } from '@/components/features/Cards/types';
import { CategoryName } from "@/lib/types";
import { allCategories } from "@/components/features/Categories/constants/categories"; // Use centralized categories

export function CardMoveOptions({
  value,
  currentCategory,
  onMoveBetweenCategories,
  onClose
}: CardMoveOptionsProps) {
  const [mounted, setMounted] = useState(false);
  const [position, setPosition] = useState({
    top: 0,
    left: 0
  });
  const updatePosition = useCallback(() => {
    const button = document.getElementById(`options-${value.id}`);
    if (button) {
      const rect = button.getBoundingClientRect();
      const isMobile = window.innerWidth < 768;
      if (isMobile) {
        setPosition({
          top: rect.bottom + window.scrollY,
          left: Math.max(10, Math.min(window.innerWidth - 210, rect.right + window.scrollX - 200))
        });
      } else {
        setPosition({
          top: rect.bottom + window.scrollY,
          left: rect.right + window.scrollX - 200
        });
      }
    }
  }, [value.id]);
  useEffect(() => {
    setMounted(true);
    updatePosition();
    window.addEventListener('resize', updatePosition);
    return () => window.removeEventListener('resize', updatePosition);
  }, [updatePosition]);
  useEffect(() => {
    const handleClickOutside = (event: Event) => {
      const target = event.target as HTMLElement;
      if (!target.closest(`#options-${value.id}`) && !target.closest('.move-options-menu')) {
        onClose();
      }
    };
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('touchstart', handleClickOutside);
    document.addEventListener('keydown', handleEscape);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
      document.removeEventListener('keydown', handleEscape);
    };
  }, [value.id, onClose]);
  const menuContent = <motion.div className="move-options-menu w-48 bg-white rounded-md shadow-lg border 
                border-gray-200 py-1 touch-manipulation" initial={{
    opacity: 0,
    y: -10
  }} animate={{
    opacity: 1,
    y: 0
  }} exit={{
    opacity: 0,
    y: -10
  }} style={{
    position: 'fixed',
    top: `${position.top}px`,
    left: `${position.left}px`,
    zIndex: 9999
  }} role="dialog" aria-label={`Move options for ${value.title}`} aria-modal="true">
      <div role="menu" aria-label="Available categories">
        {allCategories.filter(cat => cat !== currentCategory).map(category => <button key={category} type="button" onClick={() => {
        onMoveBetweenCategories(value, currentCategory, category);
        onClose();
      }} className="block w-full text-left px-4 py-3 text-sm text-gray-700 
                       hover:bg-gray-50 active:bg-gray-100 transition-colors
                       touch-manipulation select-none focus:outline-none focus:bg-gray-50
                       focus:ring-2 focus:ring-inset focus:ring-blue-500" role="menuitem" aria-label={`Move to ${category} category`}>
              Move to {category}
            </button>)}
      </div>
      <button onClick={onClose} className="sr-only" aria-label="Close move options">
        Close
      </button>
    </motion.div>;
  if (!mounted) return null;
  return createPortal(menuContent, document.getElementById('portal-root') || document.body);
}

================
File: src/components/features/Cards/components/index.ts
================
export { default as Card } from './Card';
export { AnimatedCard } from './AnimatedCard';

================
File: src/components/features/Cards/components/MobileCardActions/index.tsx
================
// src/components/Mobile/MobileCardActions.tsx
import React from 'react';
import { Value, CategoryName } from "@/lib/types";
import {MobileCardActionsProps } from "@/components/features/Cards/types";

export const MobileCardActions: React.FC<MobileCardActionsProps> = ({
  card,
  onMoveUp,
  onMoveDown,
  onMoveBetweenCategories,
  canMoveUp,
  canMoveDown,
  category
}) => {
  if (!category) return null;
  const baseButtonClasses = `
    p-2 rounded 
    focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
    transition-colors duration-200
  `;
  return <div className="flex gap-2 mt-2" role="toolbar" aria-label={`Actions for ${card.title} in ${category}`}>
      <div role="group" aria-label="Reorder controls" className="flex gap-2">
        <button onClick={onMoveUp} disabled={!canMoveUp} className={`${baseButtonClasses} ${canMoveUp ? 'bg-blue-100 hover:bg-blue-150 active:bg-blue-200 text-blue-700' : 'bg-gray-100 text-gray-400 cursor-not-allowed'}`} aria-label={`Move ${card.title} up in ${category}`} tabIndex={canMoveUp ? 0 : -1}>
          <span aria-hidden="true">↑</span>
          <span className="sr-only">Move Up</span>
        </button>
        <button onClick={onMoveDown} disabled={!canMoveDown} className={`${baseButtonClasses} ${canMoveDown ? 'bg-blue-100 hover:bg-blue-150 active:bg-blue-200 text-blue-700' : 'bg-gray-100 text-gray-400 cursor-not-allowed'}`} aria-label={`Move ${card.title} down in ${category}`} tabIndex={canMoveDown ? 0 : -1}>
          <span aria-hidden="true">↓</span>
          <span className="sr-only">Move Down</span>
        </button>
      </div>

      <button onClick={onMoveBetweenCategories} className={`${baseButtonClasses} 
          bg-blue-100 hover:bg-blue-150 active:bg-blue-200 
          flex-grow text-blue-700`} aria-label={`Move ${card.title} to different category`} aria-haspopup="true">
        <span aria-hidden="true">Move to...</span>
        <span className="sr-only">
          Select new category for {card.title}
        </span>
      </button>
    </div>;
};

================
File: src/components/features/Cards/components/styles.ts
================
export const getPostItStyles = (isDragging: boolean, isOver: boolean) => {
  const postItBaseStyles = `
    relative
    p-4
    rounded-sm
    transform
    transition-all
    duration-200
    cursor-move
    bg-gradient-to-br
    from-yellow-100
    to-yellow-200
    shadow-[2px_3px_10px_rgba(0,0,0,0.3)]
    hover:shadow-[3px_5px_12px_rgba(0,0,0,0.35)]
    ${Math.random() > 0.5 ? 'rotate-1' : '-rotate-1'}
    ${isDragging ? 'scale-105 opacity-75 z-50' : ''}
    ${isOver ? 'ring-2 ring-blue-400' : ''}
  `;

  const tapeEffect = `
    before:content-['']
    before:absolute
    before:-top-2
    before:left-1/2
    before:-translate-x-1/2
    before:w-8
    before:h-4
    before:bg-[rgba(255,255,255,0.5)]
    before:rounded-sm
    before:transform
    before:rotate-2
    after:content-['']
    after:absolute
    after:top-0
    after:left-0
    after:right-0
    after:h-8
    after:bg-gradient-to-b
    after:from-yellow-50/30
    after:to-transparent
  `;

  return { postItBaseStyles, tapeEffect };
};

================
File: src/components/features/Cards/hooks/useCardDragAnimation.ts
================
import { useState } from 'react';
import { Position } from "@/lib/types";
import { useAnimation } from '@/lib/hooks/useAnimation';
export const useCardDragAnimation = (initialPosition: Position, onDragEnd?: (endPosition: Position) => void) => {
  const [isDragging, setIsDragging] = useState(false);
  const {
    x,
    y
  } = useAnimation(initialPosition, {
    stiffness: 500,
    damping: 35,
    mass: 1
  });
  const handleDragStart = () => {
    setIsDragging(true);
  };
  const handleDragEnd = () => {
    setIsDragging(false);
    if (onDragEnd) {
      onDragEnd({
        x: x.get(),
        y: y.get()
      });
    }
  };
  return {
    isDragging,
    x,
    y,
    handleDragStart,
    handleDragEnd
  };
};

================
File: src/components/features/Cards/types.ts
================
import { Value, CategoryName } from "@/lib/types";

export interface DroppedValue extends Value {
  sourceCategory?: CategoryName;
  isInternalDrag?: boolean;
  sourceIndex?: number;
}

export interface ExtendedCardControlsProps extends CardControlsProps {
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  value: Value;
}

export interface CardProps {
  value: Value;
  columnIndex?: number;
  currentCategory?: CategoryName;
  onDrop?: (value: Value & { sourceCategory?: CategoryName }) => void;
  onMoveUp?: () => void;
  onMoveDown?: () => void;
  onMoveBetweenCategories?: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => void;
  onActiveDropZoneChange?: (category: CategoryName | null) => void;
  onClick?: (value: Value) => void;
  selectedMobileCard?: boolean;
}

export interface CardContentProps {
  title: string;
  description: string;
  isExpanded: boolean;
  controls?: React.ReactNode;
}

export interface CardControlsProps {
  onMoveUp?: () => void;
  onMoveDown?: () => void;
  onShowMoveOptions: () => void;
  currentCategory?: CategoryName;
}

export interface CardMoveOptionsProps {
  value: Value;
  currentCategory: CategoryName;
  onMoveBetweenCategories: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => void;
  onClose: () => void;
}

export interface MobileCardActionsProps {
  card: Value;
  category?: CategoryName;
  onMoveUp?: () => void;
  onMoveDown?: () => void;
  onMoveBetweenCategories: () => void;
  canMoveUp: boolean;
  canMoveDown: boolean;
}

================
File: src/components/features/Categories/components/CategoryColumn/index.tsx
================
// src/components/CategoryColumn.tsx
import { Value, CategoryName } from "@/lib/types";
import { Card } from "@/components/features/Cards/components"; // Change this import
import {CategoryColumnProps} from "@/components/features/Categories/types";

export default function CategoryColumn({
  title,
  cards,
  onDrop,
  onMoveWithinCategory,
  onMoveBetweenCategories,
  columnIndex
}: CategoryColumnProps) {
  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    e.currentTarget.classList.add('bg-gray-50');
  };
  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    e.currentTarget.classList.remove('bg-gray-50');
  };
  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    e.currentTarget.classList.remove('bg-gray-50');
    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));

      // If dropping into the same category
      if (data.sourceCategory === title) {
        const fromIndex = data.sourceIndex;
        const toIndex = cards.length; // Drop at the end
        onMoveWithinCategory(fromIndex, toIndex);
      }
      // If dropping from another category
      else if (data.sourceCategory) {
        onMoveBetweenCategories({
          id: data.id,
          title: data.title,
          description: data.description
        }, data.sourceCategory, title);
      }
      // If dropping a new card
      else {
        onDrop({
          id: data.id,
          title: data.title,
          description: data.description
        }, title);
      }
    } catch (error) {
      console.error('Error handling drop:', error);
    }
  };
  return <div className="bg-white rounded-lg shadow-sm p-4 transition-colors duration-200 w-full" data-category={title}>
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-semibold text-gray-900 flex items-center justify-between w-full">
          <span>{title}</span>
          <span className="bg-gray-100 rounded-full px-2.5 py-0.5 text-sm font-medium text-gray-600 ml-2">
            {cards.length}
          </span>
        </h2>
      </div>

      <div className="border-2 border-dashed border-gray-200 rounded-lg p-2 min-h-[400px] transition-colors duration-200" onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop} role="region" aria-label={`Drop zone for ${title} category`}>
        <div className="space-y-2">
          {cards.map((card, index) => <div key={card.id} className="transition-all duration-200">
              <Card value={card} columnIndex={index} currentCategory={title} onDrop={value => onDrop(value, title)} onMoveUp={index > 0 ? () => onMoveWithinCategory(index, index - 1) : undefined} onMoveDown={index < cards.length - 1 ? () => onMoveWithinCategory(index, index + 1) : undefined} onMoveBetweenCategories={onMoveBetweenCategories} />
            </div>)}
        </div>

        <div className={`text-gray-400 text-sm text-center py-4 mt-2 ${cards.length === 0 ? '' : 'border-t-2 border-dashed border-gray-200'}`}>
          Drop values here
        </div>
      </div>
    </div>;
}

================
File: src/components/features/Categories/components/Mobile/CategorySelectionOverlay.tsx
================
import type { CategorySelectionOverlayProps } from '@/components/features/Categories/types';
// src/components/Mobile/CategorySelectionOverlay.tsx
import React from 'react';
import { allCategories } from "@/components/features/Categories/constants/categories";
import { CategoryName } from "@/lib/types";
export const CategorySelectionOverlay: React.FC<CategorySelectionOverlayProps> = ({
  onCategorySelect,
  isVisible,
  instruction = "Select a category for this card"
}) => {
  if (!isVisible) return null;
  return <div className="fixed inset-0 bg-white z-50 flex flex-col" role="dialog" aria-modal="true" aria-labelledby="category-selection-title">
      <div className="p-4 text-center" role="heading" aria-level={2}>
        <h2 id="category-selection-title" className="text-lg font-semibold">
          {instruction}
        </h2>
      </div>

      <div className="grid grid-cols-2 gap-4 p-4" role="group" aria-label="Available categories">
        {allCategories.map((category, index) => <button key={category} onClick={() => onCategorySelect(category)} className="bg-blue-100 p-4 rounded-lg text-center font-medium 
                     hover:bg-blue-200 active:bg-blue-300 
                     focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label={`Select ${category} category`} tabIndex={0}
      // Improved keyboard navigation
      onKeyDown={e => {
        if (e.key === 'Enter' || e.key === ' ') {
          onCategorySelect(category);
        }
        // Add arrow key navigation
        if (e.key === 'ArrowRight' && index < allCategories.length - 1) {
          const nextButton = document.querySelector(`[data-category-index="${index + 1}"]`) as HTMLElement;
          nextButton?.focus();
        }
        if (e.key === 'ArrowLeft' && index > 0) {
          const prevButton = document.querySelector(`[data-category-index="${index - 1}"]`) as HTMLElement;
          prevButton?.focus();
        }
      }} data-category-index={index}>
            <span className="sr-only">Select category: </span>
            {category}
          </button>)}
      </div>

      {/* Add a hidden close button for screen readers */}
      <button onClick={() => onCategorySelect(allCategories[0])} // Default to first category
    className="sr-only" aria-label="Close category selection">
        Close
      </button>
    </div>;
};

================
File: src/components/features/Categories/constants/categories.ts
================
import { Categories, CategoryName } from "@/lib/types";
export const allCategories: CategoryName[] = ['Very Important', 'Quite Important', 'Important', 'Of Some Importance', 'Not Important'] as const;
export const emptyCategories: Categories = allCategories.reduce((acc, category) => {
  acc[category] = [];
  return acc;
}, {} as Categories);

// Create a constant for initial categories
export const initialCategories: Categories = {
  'Very Important': [],
  'Quite Important': [],
  'Important': [],
  'Of Some Importance': [],
  'Not Important': []
};

================
File: src/components/features/Categories/types.ts
================
// Generated types file

import { CategoryName,Value } from "@/lib/types";

export interface CategoryColumnProps {
  title: CategoryName;
  cards: Value[];
  onDrop: (value: Value, category: CategoryName) => void;
  onMoveWithinCategory: (fromIndex: number, toIndex: number) => void;
  onMoveBetweenCategories: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => void;
  columnIndex?: number;
}
export interface CategorySelectionOverlayProps {
  onCategorySelect: (category: CategoryName) => void;
  isVisible: boolean;
  instruction?: string;
}

================
File: src/components/features/Categories/utils/categoryUtils.ts
================
import { Categories, CategoryName, Value } from "@/lib/types";
import { getGameConfig } from "@/lib/utils/config/gameConfig";
export const getImportantCards = (categories: Categories): Value[] => {
  const importantCards: Value[] = [];

  // Always check Very Important as it exists in all rounds
  if ('Very Important' in categories) {
    importantCards.push(...categories['Very Important']);
  }

  // Check optional categories based on round type
  if ('Quite Important' in categories && categories['Quite Important']) {
    importantCards.push(...categories['Quite Important']);
  }
  if ('Important' in categories && categories['Important']) {
    importantCards.push(...categories['Important']);
  }
  if ('Of Some Importance' in categories && categories['Of Some Importance']) {
    importantCards.push(...categories['Of Some Importance']);
  }
  return importantCards;
};
export const getCategoriesForRound = (cardCount: number, targetValue: number): Categories => {
  const ratio = cardCount / targetValue;
  const {
    ratioThresholds
  } = getGameConfig();
  const categories = {} as Categories;
  if (ratio <= ratioThresholds.final) {
    categories['Very Important'] = [];
    categories['Not Important'] = [];
  } else if (ratio <= ratioThresholds.reduced) {
    categories['Very Important'] = [];
    categories['Quite Important'] = [];
    categories['Not Important'] = [];
  } else if (ratio <= ratioThresholds.standard) {
    categories['Very Important'] = [];
    categories['Quite Important'] = [];
    categories['Important'] = [];
    categories['Not Important'] = [];
  } else {
    categories['Very Important'] = [];
    categories['Quite Important'] = [];
    categories['Important'] = [];
    categories['Of Some Importance'] = [];
    categories['Not Important'] = [];
  }
  return categories;
};
export const getCategoryNames = (ratio: number): CategoryName[] => {
  if (ratio <= 1.5) {
    return ['Very Important', 'Not Important'];
  } else if (ratio <= 2) {
    return ['Very Important', 'Quite Important', 'Not Important'];
  } else if (ratio <= 3) {
    return ['Very Important', 'Quite Important', 'Important', 'Not Important'];
  }
  return ['Very Important', 'Quite Important', 'Important', 'Of Some Importance', 'Not Important'];
};

================
File: src/components/features/Game/commands/BaseCommand.ts
================
import { Command } from "@/lib/types/Command";
import { Position } from "@/lib/types/Position";
export abstract class BaseCommand implements Command {
  public readonly timestamp: number;
  constructor(public readonly type: string, public readonly payload: unknown) {
    this.timestamp = Date.now();
  }
  public sourcePosition?: Position;
  public targetPosition?: Position;
  setPositions(source?: Position, target?: Position): Command {
    this.sourcePosition = source;
    this.targetPosition = target;
    return this;
  }
}

================
File: src/components/features/Game/commands/Command.ts
================
import { Position } from "@/lib/types";
export class Command {
  type: string;
  payload: any;
  timestamp: number;
  sourcePosition?: Position;
  targetPosition?: Position;
  constructor(type: string, payload: any) {
    this.type = type;
    this.payload = payload;
    this.timestamp = Date.now();
  }
  setPositions(source?: Position, target?: Position) {
    this.sourcePosition = source;
    this.targetPosition = target;
    return this;
  }
}

================
File: src/components/features/Game/commands/DropCommand.ts
================
import { BaseCommand } from './BaseCommand';
import { CategoryName, Value } from "@/lib/types";
import { getCardPosition, getCategoryPosition } from "@/lib/utils";
import { DropCommandPayload } from "@/lib/types";
export class DropCommand extends BaseCommand {
  constructor(value: Value, category: CategoryName) {
    const payload: DropCommandPayload = {
      cardId: value.id,
      cardTitle: value.title,
      category
    };
    super('DROP', payload);

    // Capture positions when command is created
    const sourcePos = getCardPosition(value.id);
    const targetPos = getCategoryPosition(category);
    this.setPositions(sourcePos, targetPos);
  }
  getPayload(): DropCommandPayload {
    return this.payload as DropCommandPayload;
  }
}

================
File: src/components/features/Game/commands/MoveCommand.ts
================
import { BaseCommand } from './BaseCommand';
import { CategoryName, Value } from "@/lib/types";
import { getCardPosition, getCategoryPosition } from "@/lib/utils/dom";
import { MoveCommandPayload } from "@/lib/types";
export class MoveCommand extends BaseCommand {
  constructor(value: Value, fromCategory: CategoryName, toCategory: CategoryName, fromIndex?: number, toIndex?: number) {
    const payload: MoveCommandPayload = {
      cardId: value.id,
      cardTitle: value.title,
      fromCategory,
      toCategory,
      fromIndex,
      toIndex
    };
    super('MOVE', payload);

    // Capture positions when command is created
    const sourcePos = getCardPosition(value.id);
    const targetPos = getCategoryPosition(toCategory);
    this.setPositions(sourcePos, targetPos);
  }
  getPayload(): MoveCommandPayload {
    return this.payload as MoveCommandPayload;
  }
}

================
File: src/components/features/Game/components/CoreValueReasoning/index.tsx
================
// src/components/CoreValueReasoning.tsx
import { useEffect, useState } from 'react';
import { Value, ValueWithReason } from "@/lib/types";
import { motion } from 'framer-motion';
import { getPostItStyles } from "@/components/features/Cards/components/styles";
import {CoreValueReasoningProps} from '@/components/features/Game/types';

export function CoreValueReasoning({
  values,
  onComplete
}: CoreValueReasoningProps) {
  const [reasons, setReasons] = useState<Record<string, string>>({});
  const {
    postItBaseStyles,
    tapeEffect
  } = getPostItStyles(false, false);
  useEffect(() => {
    // Check if all values have non-empty reasons
    const hasAllReasons = values.every(value => reasons[value.id]?.trim());
  }, [reasons, values]);
  const handleReasonChange = (valueId: string, reason: string) => {
    setReasons(prev => ({
      ...prev,
      [valueId]: reason
    }));
  };
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const valuesWithReasons: ValueWithReason[] = values.map(value => ({
      ...value,
      reason: reasons[value.id]?.trim() || '' // Empty string if no reason given
    }));
    onComplete(valuesWithReasons);
  };
  return <div className="container mx-auto px-4 py-8" role="region" aria-labelledby="reasoning-title">
            <h1 id="reasoning-title" className="text-2xl font-bold mb-6">
                Why are these values meaningful to you?
            </h1>
            <p className="text-gray-600 mb-6">
                Optionally, explain why each value is meaningful to you. This can help you reflect on your choices.
            </p>
            
            <form onSubmit={handleSubmit} className="space-y-6">
                <div className="space-y-6 mb-8" role="list" aria-label="Value reflection entries">
                    {values.map((value, index) => <motion.div key={value.id} className={`${postItBaseStyles} ${tapeEffect} p-6`} initial={{
          opacity: 0,
          y: 20
        }} animate={{
          opacity: 1,
          y: 0
        }} role="listitem">
                            <div role="group" aria-labelledby={`value-title-${value.id}`}>
                                <h2 id={`value-title-${value.id}`} className="font-bold text-lg mb-2">
                                    {value.title}
                                </h2>
                                <p className="text-gray-600 mb-4">
                                    {value.description}
                                </p>
                                <div>
                                    <label htmlFor={`reason-${value.id}`} className="block text-sm font-medium text-gray-700 mb-2">
                                        Why is this value meaningful to you? (Optional)
                                    </label>
                                    <textarea id={`reason-${value.id}`} className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500" rows={3} value={reasons[value.id] || ''} onChange={e => handleReasonChange(value.id, e.target.value)} placeholder="Share your thoughts... (optional)" aria-label={`Reasoning for ${value.title}`} />
                                </div>
                            </div>
                        </motion.div>)}
                </div>
                
                <div className="flex justify-end">
                    <button type="submit" className="px-6 py-2 rounded-md transition-colors bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Save reasons and view results">
                        Continue to Results
                    </button>
                </div>
            </form>
        </div>;
}

================
File: src/components/features/Game/components/Results/index.tsx
================
// src/components/Results.tsx
'use client';

import { getPostItStyles } from "@/components/features/Cards/components/styles";
import { useRef, useEffect, useState } from 'react';
import { ValueWithReason, Categories, CategoryName } from "@/lib/types";
import Link from 'next/link';
import { useGameState } from "@/components/features/Game/hooks/useGameState";
import { clearGameState } from "@/lib/utils/storage";
import { getCompletedSession } from "@/lib/db/indexedDB";
import { useSession } from "@/components/features/Game/hooks/useSession";
export default function Results() {
  const printRef = useRef<HTMLDivElement>(null);
  const [mounted, setMounted] = useState(false);
  const {
    categories
  } = useGameState();
  const {
    sessionId
  } = useSession();
  const [enrichedCategories, setEnrichedCategories] = useState<Categories>(categories);
  useEffect(() => {
    setMounted(true);
    const enrichCategoriesWithReasons = async () => {
      if (sessionId) {
        try {
          const completedSession = await getCompletedSession(sessionId);
          if (completedSession?.finalValues) {
            const reasonsMap = Object.fromEntries(completedSession.finalValues.map(value => [value.id, value.reason]));
            const enriched = Object.entries(categories).reduce((acc, [category, values = []]) => {
              acc[category as CategoryName] = values.map(value => ({
                ...value,
                reason: reasonsMap[value.id]
              }));
              return acc;
            }, {} as Categories);
            setEnrichedCategories(enriched);
          }
        } catch (error) {
          console.error('Failed to load reasons:', error);
        }
      }
    };
    enrichCategoriesWithReasons();
  }, [sessionId, categories]);
  const handlePrint = () => {
    const printContent = printRef.current;
    if (!printContent) return;
    const winPrint = window.open('', '', 'left=0,top=0,width=800,height=900,toolbar=0,scrollbars=0,status=0');
    if (!winPrint) return;
    const style = document.createElement('style');
    style.textContent = `
      @media print {
        body { font-size: 12pt; }
        h1 { font-size: 24pt; }
        h2 { font-size: 18pt; }
        h3 { font-size: 14pt; }
      }
    `;
    winPrint.document.head.appendChild(style);
    winPrint.document.write(printContent.innerHTML);
    winPrint.document.close();
    winPrint.focus();
    winPrint.print();
    winPrint.close();
  };
  const handleNewExercise = () => {
    clearGameState();
  };
  const {
    postItBaseStyles,
    tapeEffect
  } = getPostItStyles(false, false);
  if (!mounted) return null;
  return <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8 lg:py-12" role="region" aria-labelledby="results-title">
      <div ref={printRef} className="bg-white rounded-lg shadow-sm p-4 sm:p-6 lg:p-8">
        <h1 id="results-title" className="text-2xl sm:text-3xl lg:text-4xl font-bold mb-4 sm:mb-6 lg:mb-8 text-gray-900">
          Your Core Values Results
        </h1>

        <div className="space-y-6 sm:space-y-8 lg:space-y-10" role="list" aria-label="Categories and values">
          {(Object.entries(enrichedCategories) as [CategoryName, ValueWithReason[]][]).filter(([_, values]) => values && values.length > 0).map(([category, values]) => <section key={category} className="bg-gray-50 rounded-lg p-4 sm:p-6" aria-labelledby={`category-${category.toLowerCase().replace(/\s+/g, '-')}`}>
                <h2 id={`category-${category.toLowerCase().replace(/\s+/g, '-')}`} className="text-xl sm:text-2xl font-semibold mb-3 sm:mb-4 text-gray-800">
                  {category}
                </h2>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4 lg:gap-6" role="list" aria-label={`Values in ${category}`}>
                  {values.map((value: ValueWithReason) => <article key={value.id} className={`${postItBaseStyles} ${tapeEffect} p-4`} role="listitem">
                      <h3 className="font-medium text-base sm:text-lg text-gray-900 mb-2">
                        {value.title}
                      </h3>
                      <p className="text-sm sm:text-base text-gray-600 mb-3">
                        {value.description}
                      </p>
                      {value.reason && <div className="mt-3 pt-3 border-t border-gray-200" aria-label={`Personal meaning for ${value.title}`}>
                          <p className="text-sm font-medium text-gray-700 mb-1">
                            Why it is meaningful:
                          </p>
                          <p className="text-sm sm:text-base text-gray-600 italic">
                            {value.reason}
                          </p>
                        </div>}
                    </article>)}
                </div>
              </section>)}
        </div>
      </div>

      <div className="mt-6 sm:mt-8 lg:mt-10 flex flex-col sm:flex-row items-center justify-center gap-3 sm:gap-4" role="group" aria-label="Result actions">
        <button onClick={handlePrint} className="w-full sm:w-auto px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Print your results">
          Print Results
        </button>

        <Link href="/" onClick={handleNewExercise} className="w-full sm:w-auto px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors text-center focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" aria-label="Start a new values exercise">
          Start New Exercise
        </Link>

        <Link href="/history" className="text-blue-600 hover:text-blue-800 underline focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded px-2 py-1" aria-label="View all your previous results">
          View All Previous Results
        </Link>
      </div>
    </div>;
}

================
File: src/components/features/Game/components/StartScreen/index.tsx
================
// src/components/StartScreen.tsx
'use client';

import { useState } from 'react';
import { StartScreenProps } from './types';
import { getEnvNumber, getEnvBoolean } from "@/lib/utils/config";
import Link from 'next/link';
import { addSession } from "@/lib/db/indexedDB";
import { initializeGameState } from "@/lib/utils/storage";
import valuesData from '@/data/values.json';
import { getRandomValues } from "../../utils";
export default function StartScreen({
  onStart
}: StartScreenProps) {
  const isDebug = getEnvBoolean('debug', false);
  const maxCards = getEnvNumber('maxCards', 35);
  const defaultCoreValues = getEnvNumber('numCoreValues', 5);
  const [coreValuesCount, setCoreValuesCount] = useState<number>(defaultCoreValues);
  const handleStart = async () => {
    const session = {
      timestamp: Date.now(),
      targetCoreValues: coreValuesCount,
      currentRound: 1,
      completed: false
    };
    const sessionId = await addSession(session);
    const shuffledValues = getRandomValues(valuesData.values);
    const limitedValues = shuffledValues.slice(0, maxCards);
    initializeGameState(sessionId, coreValuesCount, limitedValues, {
      'Very Important': [],
      'Quite Important': [],
      'Important': [],
      'Of Some Importance': [],
      'Not Important': []
    });
    onStart();
  };
  return <div className="h-[calc(100vh-4rem)] overflow-y-auto" // Changed this line
  role="main" aria-labelledby="welcome-heading">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4 sm:py-8">
        <h1 id="welcome-heading" className="text-3xl sm:text-4xl md:text-5xl font-extrabold text-center mb-4 sm:mb-6">
          <span className="text-gray-900">Discover Your </span>
          <span className="text-blue-600">Core Values</span>
        </h1>

        <div className="max-w-2xl mx-auto text-center space-y-3 sm:space-y-4 mb-6 sm:mb-8" aria-label="Introduction">
          <p className="text-base sm:text-lg text-gray-700">
            Welcome to the Core Values discovery exercise! Through this interactive experience,
            you will discover and prioritise your personal core values, helping you identify what matters most to you.
          </p>
        </div>

        {isDebug && <div className="mb-4 text-xs sm:text-sm text-gray-600 text-center" role="note" aria-label="Debug information">
            <div>Debug Mode: On</div>
            <div>Max Cards: {maxCards}</div>
            <div>Default Core Values: {defaultCoreValues}</div>
          </div>}

        <form onSubmit={e => {
        e.preventDefault();
        handleStart();
      }} className="flex flex-col sm:flex-row items-center justify-center gap-4 sm:gap-6" aria-label="Exercise configuration">
          <label htmlFor="core-values-count" className="text-base sm:text-lg font-medium text-center sm:text-left whitespace-normal sm:whitespace-nowrap">
            How many core values do you want to end up with?
          </label>
          <div className="flex gap-3 sm:gap-4 items-center">
            <input id="core-values-count" type="number" min="1" max="10" value={coreValuesCount} onChange={e => setCoreValuesCount(Number(e.target.value))} className="border rounded p-2 w-16 sm:w-20 text-center shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500" aria-label="Number of core values" required />
            <button type="submit" className="px-4 sm:px-8 py-2 sm:py-3 bg-blue-600 text-white font-medium rounded-md hover:bg-blue-700 transition-colors duration-200 shadow-sm text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Begin the core values exercise">
              Start Exercise
            </button>
          </div>
        </form>

        <div className="mt-6 sm:mt-8 text-center" aria-label="Previous results navigation">
          <p className="text-gray-600 mb-2 text-sm sm:text-base">
            Have you completed this exercise before?
          </p>
          <Link href="/history" className="text-blue-600 hover:text-blue-800 underline font-medium text-sm sm:text-base inline-flex items-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded px-2 py-1" aria-label="View your previous exercise results">
            <span>View Your Previous Results</span>
            <span aria-hidden="true" className="ml-1">→</span>
          </Link>
        </div>
      </div>
    </div>;
}

================
File: src/components/features/Game/components/StartScreen/types.ts
================
'use client';
export interface StartScreenProps {
  onStart: () => void;
}

================
File: src/components/features/Game/hooks/useCommands.ts
================
'use client';

import { useCallback } from 'react';
import { useStore } from "@/lib/store/store";
import { Value, CategoryName } from "@/lib/types";
import { getRound, saveRound } from "@/lib/db/indexedDB";
import { DropCommand } from "@/components/features/Game/commands/DropCommand";
import { MoveCommand } from "@/components/features/Game/commands/MoveCommand";
import { shallow } from 'zustand/shallow';
export function useCommands() {
  const state = useStore(state => ({
    addCommand: state.addCommand,
    currentRound: state.currentRound,
    commands: state.commands,
    clearCommands: state.clearCommands,
    roundNumber: state.roundNumber,
    currentRoundCommands: state.currentRoundCommands
  }), shallow);
  const handleDrop = useCallback(async (value: Value, category: CategoryName) => {
    const command = new DropCommand(value, category);
    await state.addCommand(command);
  }, [state]);
  const handleMoveBetweenCategories = useCallback(async (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => {
    const command = new MoveCommand(value, fromCategory, toCategory);
    await state.addCommand(command);
  }, [state]);
  const handleMoveWithinCategory = useCallback(async (category: CategoryName, fromIndex: number, toIndex: number, value: Value) => {
    const command = new MoveCommand(value, category, category, fromIndex, toIndex);
    await state.addCommand(command);
  }, [state]);
  const loadCommands = useCallback(async () => {
    if (state.currentRound) {
      const savedRound = await getRound(state.currentRound.sessionId, state.roundNumber);
      if (savedRound) {
        useStore.setState({
          currentRound: {
            sessionId: state.currentRound.sessionId,
            roundNumber: state.roundNumber,
            commands: savedRound.commands,
            availableCategories: state.currentRound.availableCategories,
            timestamp: savedRound.timestamp
          }
        });
      }
    }
  }, [state]);
  return {
    handleDrop,
    handleMoveBetweenCategories,
    handleMoveWithinCategory,
    loadCommands,
    currentRoundCommands: state.currentRoundCommands,
    addCommand: state.addCommand,
    clearCommands: state.clearCommands
  };
}

================
File: src/components/features/Game/hooks/useGameState.ts
================
'use client';

import { useStore } from "@/lib/store/store";
import { shallow } from 'zustand/shallow';
export function useGameState() {
  const state = useStore(state => ({
    remainingCards: state.remainingCards,
    categories: state.categories,
    isGameStarted: state.isGameStarted,
    showInstructions: state.showInstructions,
    commands: state.commands,
    currentRound: state.currentRound,
    addCommand: state.addCommand,
    setRemainingCards: state.setRemainingCards,
    setCategories: state.setCategories,
    setGameStarted: state.setGameStarted,
    setShowInstructions: state.setShowInstructions,
    resetGame: state.resetGame,
    clearCommands: state.clearCommands
  }), shallow);
  return state;
}

================
File: src/components/features/Game/hooks/useSession.ts
================
'use client';

import { useStore } from "@/lib/store/store";
import { shallow } from 'zustand/shallow';
export function useSession() {
  const state = useStore(state => ({
    sessionId: state.sessionId,
    roundNumber: state.roundNumber,
    targetCoreValues: state.targetCoreValues,
    setSession: state.setSession,
    setSessionId: state.setSessionId,
    setRoundNumber: state.setRoundNumber,
    setTargetCoreValues: state.setTargetCoreValues,
    clearSession: state.clearSession
  }), shallow);
  return state;
}

================
File: src/components/features/Game/types.ts
================
import { Value, CategoryName } from "@/lib/types";

export interface StartScreenProps {
  onStart: () => void;
}

export interface ResultsProps {
  sessionId?: string;
  values?: Value[];
}

export interface CoreValueReasoningProps {
  values: Value[];
  onComplete: (valuesWithReasons: ValueWithReason[]) => void;
}

export interface ValueWithReason extends Value {
  reason?: string;
}

export interface CoreValueReasoningProps {
  values: Value[];
  onComplete: (valuesWithReasons: ValueWithReason[]) => void;
}

================
File: src/components/features/Game/utils/index.ts
================
import { getRandomValues } from './valuesUtils';
import { generateSessionName, getSessions } from './sessionUtils';

export {
    getRandomValues,
    generateSessionName,
    getSessions
};

================
File: src/components/features/Game/utils/sessionUtils.ts
================
import { Session } from "@/lib/types";
import { IDBPDatabase } from 'idb';
export const adjectives: string[] = ['happy', 'bright', 'swift', 'clever', 'gentle', 'brave', 'calm', 'dark', 'eager', 'fair', 'wise', 'kind', 'loud', 'merry', 'nice', 'proud', 'quick', 'rare', 'soft', 'tall', 'warm', 'young', 'wild', 'bold', 'cool', 'deep', 'pure', 'rich', 'safe', 'sharp', 'strong', 'sweet', 'tough', 'vast', 'vivid', 'light', 'quiet', 'smart', 'fresh', 'grand', 'clean', 'clear', 'great', 'free', 'broad', 'keen', 'real', 'true', 'full', 'fine'];
export const nouns: string[] = ['river', 'mountain', 'forest', 'star', 'ocean', 'cloud', 'desert', 'garden', 'island', 'lake', 'moon', 'rain', 'snow', 'storm', 'sun', 'tree', 'valley', 'wind', 'world', 'bridge', 'castle', 'city', 'door', 'field', 'fire', 'flower', 'harbor', 'home', 'light', 'path', 'road', 'rock', 'shore', 'sky', 'space', 'spring', 'stone', 'stream', 'summer', 'tide', 'tower', 'trail', 'wave', 'wood', 'dawn', 'dusk', 'echo', 'frost', 'mist', 'shadow'];
export const verbs: string[] = ['running', 'dancing', 'singing', 'jumping', 'flying', 'dreaming', 'glowing', 'hoping', 'laughing', 'playing', 'reading', 'sailing', 'thinking', 'walking', 'writing', 'seeking', 'growing', 'flowing', 'shining', 'smiling', 'breathing', 'climbing', 'creating', 'drifting', 'exploring', 'floating', 'listening', 'moving', 'painting', 'rising', 'speaking', 'swimming', 'teaching', 'watching', 'wondering', 'building', 'caring', 'drinking', 'eating', 'feeling', 'helping', 'knowing', 'learning', 'making', 'resting', 'seeing', 'sleeping', 'standing', 'trying', 'working'];
const getRandomElement = <T,>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
};
export async function generateSessionName(db: IDBPDatabase): Promise<string> {
  let isUnique = false;
  let sessionName = '';
  let attempts = 0;
  const maxAttempts = 50; // Prevent infinite loop

  while (!isUnique && attempts < maxAttempts) {
    const adj = getRandomElement(adjectives);
    const noun = getRandomElement(nouns);
    const verb = getRandomElement(verbs);
    sessionName = `${adj}-${noun}-${verb}`;

    // Check if session exists in IndexedDB
    const existingSession = await db.get('sessions', sessionName);
    if (!existingSession) {
      isUnique = true;
    }
    attempts++;
  }
  if (!isUnique) {
    // If we couldn't generate a unique name after maxAttempts,
    // append a timestamp to ensure uniqueness
    sessionName = `${sessionName}-${Date.now()}`;
  }
  return sessionName;
}
export const getSessions = async (db: IDBPDatabase): Promise<Session[]> => {
  try {
    const sessions = await db.getAll('sessions');
    return sessions;
  } catch (error) {
    console.error('Error retrieving sessions:', error);
    return [];
  }
};

================
File: src/components/features/Game/utils/valuesUtils.ts
================
import { Value } from "@/lib/types";
export const getRandomValues = (values: Value[]): Value[] => {
  const shuffled = [...values].sort(() => Math.random() - 0.5);
  return shuffled;
};

================
File: src/components/features/History/components/SessionList/index.tsx
================
// src/components/History/SessionList.tsx
import { useState, useEffect } from 'react';
import { Session, Value, CompletedSession, ValueWithReason } from "@/lib/types";
import Link from 'next/link';
import { motion, AnimatePresence } from 'framer-motion';
import { getPostItStyles } from "@/components/features/Cards/components/styles";
import { getCompletedSession } from "@/lib/db/indexedDB";
import { useMobile } from "@/lib/contexts/MobileContext"; // Use the MobileContext instead
import { SessionListProps} from '@/components/features/History/types';

export function SessionList({
  sessions
}: SessionListProps) {
  const [showValuesFor, setShowValuesFor] = useState<string | null>(null);
  const [currentValues, setCurrentValues] = useState<Value[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const {
    isMobile
  } = useMobile(); // Use the mobile context
  const {
    postItBaseStyles,
    tapeEffect
  } = getPostItStyles(false, false);
  const formatDate = (timestamp: number) => {
    return new Date(timestamp).toLocaleString();
  };
  const handleShowValues = async (sessionId: string) => {
    setIsLoading(true);
    try {
      const completedSession = await getCompletedSession(sessionId);
      if (completedSession?.finalValues) {
        setCurrentValues(completedSession.finalValues);
        setShowValuesFor(sessionId);
      }
    } catch (error) {
      console.error('Error loading values:', error);
    } finally {
      setIsLoading(false);
    }
  };
  const renderCompletedValues = (values: ValueWithReason[]) => {
    if (isLoading) {
      return <div className="flex items-center justify-center p-4" role="status" aria-label="Loading values">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" aria-hidden="true" />
          <span className="sr-only">Loading values...</span>
        </div>;
    }
    if (isMobile) {
      return <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50" role="dialog" aria-modal="true" aria-labelledby="mobile-values-title">
          <div className="bg-white rounded-lg p-4 max-w-sm w-full max-h-[80vh] overflow-y-auto" role="document">
            <div className="flex justify-between items-center mb-4">
              <h3 id="mobile-values-title" className="text-lg font-bold">
                Core Values
              </h3>
              <span className="text-sm text-gray-500" aria-label={`Total values: ${values.length}`}>
                {values.length} value{values.length !== 1 ? 's' : ''}
              </span>
            </div>
            <div className="space-y-4" role="list" aria-label="Selected core values">
              {values.map(value => <div key={value.id} className="p-4 bg-yellow-50 rounded shadow" role="listitem">
                  <h4 className="font-medium">{value.title}</h4>
                  <p className="text-sm text-gray-600 mb-2">{value.description}</p>
                  {value.reason && <div className="mt-2 pt-2 border-t border-gray-200" aria-label={`Reasoning for ${value.title}`}>
                      <p className="text-sm font-medium text-gray-700">Why it is meaningful:</p>
                      <p className="text-sm text-gray-600 italic">
                        {value.reason || "No reason given"}
                      </p>
                    </div>}
                </div>)}
            </div>
            <button onClick={() => setShowValuesFor(null)} className="mt-4 w-full px-4 py-2 bg-blue-600 text-white rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Close values view">
              Close
            </button>
          </div>
        </div>;
    }
    return <section className="space-y-4" aria-labelledby="desktop-values-title">
        <div className="flex justify-between items-center">
          <h3 id="desktop-values-title" className="text-lg font-bold">
            Selected Core Values
          </h3>
          <span className="text-sm text-gray-500" aria-label={`Total values: ${values.length}`}>
            {values.length} value{values.length !== 1 ? 's' : ''}
          </span>
        </div>
        <div className="grid grid-cols-3 gap-4" role="list" aria-label="Core values grid">
          {values.map(value => <motion.article key={value.id} className={`${postItBaseStyles} ${tapeEffect} p-4`} initial={{
          opacity: 0,
          y: 20
        }} animate={{
          opacity: 1,
          y: 0
        }} exit={{
          opacity: 0,
          y: -20
        }} role="listitem">
              <h4 className="font-medium">{value.title}</h4>
              <p className="text-sm text-gray-600 mb-2">{value.description}</p>
              {value.reason && <div className="mt-2 pt-2 border-t border-gray-200" aria-label={`Reasoning for ${value.title}`}>
                  <p className="text-sm font-medium text-gray-700">Why it is meaningful:</p>
                  <p className="text-sm text-gray-600 italic">
                    {value.reason || "No reason given"}
                  </p>
                </div>}
            </motion.article>)}
        </div>
      </section>;
  };
  if (isMobile) {
    return <div className="space-y-4" role="list" aria-label="Session history">
        {sessions.map(session => <article key={session.id} className="bg-white rounded-lg shadow p-4" role="listitem">
            <div className="flex justify-between items-start mb-2">
              <div>
                <time dateTime={new Date(session.timestamp).toISOString()} className="text-sm text-gray-500">
                  {formatDate(session.timestamp)}
                </time>
                <div className="text-sm mt-1">
                  Target Values: {session.targetCoreValues}
                </div>
                <div className="text-sm">
                  Round: {session.currentRound}
                </div>
              </div>
              <div className={`text-sm ${session.completed ? 'text-green-600' : 'text-blue-600'}`} role="status">
                {session.completed ? 'Completed' : 'In Progress'}
              </div>
            </div>
            <div className="mt-3 flex justify-end">
              {session.completed ? <button onClick={() => handleShowValues(session.id)} className="px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" aria-label={`Show values for session from ${formatDate(session.timestamp)}`}>
                  Show Values
                </button> : <Link href={`/?sessionId=${session.id}`} className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label={`Resume session from ${formatDate(session.timestamp)}`}>
                  Resume Game
                </Link>}
            </div>
          </article>)}
        <AnimatePresence>
          {showValuesFor && renderCompletedValues(currentValues)}
        </AnimatePresence>
      </div>;
  }
  return <div className="space-y-4">
      <table className="min-w-full bg-white shadow-md rounded-lg" role="table" aria-label="Session history">
        <thead>
          <tr className="bg-gray-50 border-b" role="row">
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Session ID
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Last Updated
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Target Values
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Current Round
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Status
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Actions
            </th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-200">
          {sessions.map(session => <tr key={session.id} className="hover:bg-gray-50" role="row">
              <td className="px-6 py-4 whitespace-nowrap text-xs text-gray-500 font-mono" role="cell">
                {session.id}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500" role="cell">
                <time dateTime={new Date(session.timestamp).toISOString()}>
                  {formatDate(session.timestamp)}
                </time>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500" role="cell">
                {session.targetCoreValues}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500" role="cell">
                {session.currentRound}
              </td>
              <td className="px-6 py-4 whitespace-nowrap" role="cell">
                <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full 
                    ${session.completed ? 'bg-green-50 text-green-700' : 'bg-blue-50 text-blue-700'}`} role="status">
                  {session.completed ? 'Completed' : 'In Progress'}
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2" role="cell">
                {session.completed ? <>
                    <button onClick={() => handleShowValues(session.id)} className="px-3 py-1.5 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" aria-label={`Show values for session from ${formatDate(session.timestamp)}`}>
                      Show Values
                    </button>
                    {process.env.NODE_ENV === 'development' && <Link href={`/replay?sessionId=${session.id}`} className="px-3 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label={`Replay session from ${formatDate(session.timestamp)}`}>
                        Replay
                      </Link>}
                  </> : <Link href={`/?sessionId=${session.id}`} className="px-3 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label={`Resume session from ${formatDate(session.timestamp)}`}>
                    Resume Game
                  </Link>}
              </td>
            </tr>)}
        </tbody>
      </table>
      <AnimatePresence>
        {showValuesFor && <div className="bg-white shadow-md rounded-lg p-6" role="region" aria-label="Selected values details">
            {renderCompletedValues(currentValues)}
          </div>}
      </AnimatePresence>
    </div>;
}

================
File: src/components/features/History/types.ts
================
import { Session, Value } from "@/lib/types";


export interface SessionListProps {
  sessions: Session[];
  onShowValues?: (sessionId: string) => Promise<Value[]>;
}

================
File: src/components/features/Replay/components/MobileReplayCategories/index.tsx
================
// src/components/Replay/components/MobileReplayCategories.tsx
import { Categories, CategoryName, Value } from "@/lib/types";
import { allCategories } from "@/components/features/Categories/constants/categories"; // Use centralized categories

export function MobileReplayCategory({
  title,
  cards
}: {
  title: CategoryName;
  cards: Value[];
}) {
  const categoryId = `mobile-replay-category-${title.toLowerCase().replace(/\s+/g, '-')}`;
  return <div data-category={title} className="p-2 rounded-lg border bg-white border-gray-200" role="region" aria-labelledby={categoryId}>
            <div className="flex items-center justify-between">
                <h3 id={categoryId} className="font-medium text-xs sm:text-sm truncate">
                    {title}
                </h3>
                <span className="bg-gray-200 px-1.5 py-0.5 rounded-full text-xs" aria-label={`${cards.length} ${cards.length === 1 ? 'card' : 'cards'}`}>
                    {cards.length}
                </span>
            </div>
            {cards.length > 0 && <div className="mt-1 space-y-1" role="list" aria-label={`Values in ${title}`}>
                    {cards.map(card => <div key={card.id} className="text-xs text-gray-600 truncate" role="listitem" aria-label={card.title}>
                            {card.title}
                        </div>)}
                </div>}
        </div>;
}
export function MobileReplayCategories({
  categories
}: {
  categories: Categories;
}) {
  return <div className="w-full space-y-1" role="region" aria-label="Value categories replay view">
            <div className="w-full" role="group" aria-label="Primary category">
                <MobileReplayCategory title="Very Important" cards={categories['Very Important'] || []} />
            </div>
            
            <div className="grid grid-cols-2 gap-1" role="group" aria-label="Secondary categories">
                <MobileReplayCategory title="Quite Important" cards={categories['Quite Important'] || []} />
                <MobileReplayCategory title="Important" cards={categories['Important'] || []} />
            </div>
            
            <div className="grid grid-cols-2 gap-1" role="group" aria-label="Additional categories">
                <MobileReplayCategory title="Of Some Importance" cards={categories['Of Some Importance'] || []} />
                <MobileReplayCategory title="Not Important" cards={categories['Not Important'] || []} />
            </div>
        </div>;
}

================
File: src/components/features/Replay/components/ReplayClient/index.tsx
================
'use client';

import { useEffect, useState, useCallback, useMemo } from 'react';
import { useSearchParams } from 'next/navigation';
import { getRoundsBySession } from "@/lib/db/indexedDB";
import { Round, Value, CategoryName, DropCommandPayload, MoveCommandPayload, Command, Categories } from "@/lib/types";
import { getEnvBoolean } from "@/lib/utils/config";
import { AnimatedCard } from "@/components/features/Cards/components";
import { useReplayState } from '../../hooks/useReplayState';
import { useCardAnimation } from '../../hooks/useCardAnimation';
import { ReplayColumn } from '../ReplayColumn';
import { motion, useSpring } from 'framer-motion';
import { MobileReplayCategories } from '../MobileReplayCategories';
import { CommandInfo} from '@/components/features/Replay/types';

export default function ReplayClient() {
  const searchParams = useSearchParams();
  const sessionId = searchParams.get('sessionId');
  const debug = getEnvBoolean('debug', false);
  const [rounds, setRounds] = useState<Round[]>([]);
  const [currentRound, setCurrentRound] = useState<number>(1);
  const [currentCommandIndex, setCurrentCommandIndex] = useState<number>(0);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [playbackSpeed, setPlaybackSpeed] = useState<number>(1);
  const [commandInfo, setCommandInfo] = useState<CommandInfo | null>(null);
  const [currentCard, setCurrentCard] = useState<Value | null>(null);
  const [isMobile, setIsMobile] = useState<boolean | null>(null);
  const [isRoundTransition, setIsRoundTransition] = useState(false);
  const [allCards, setAllCards] = useState<Value[]>([]);
  const {
    categories,
    animatingCard,
    executeCommand,
    resetCategories,
    setAnimatingCard,
    setAllCards: setReplayStateCards
  } = useReplayState();
  const x = useSpring(0, {
    stiffness: 100,
    damping: 15,
    mass: 1,
    duration: 0.75
  });
  const y = useSpring(0, {
    stiffness: 100,
    damping: 15,
    mass: 1,
    duration: 0.75
  });
  const {
    position,
    isAnimating,
    startAnimation
  } = useCardAnimation(animatingCard?.sourcePos || {
    x: 0,
    y: 0
  }, animatingCard?.targetPos || {
    x: 0,
    y: 0
  }, 1000 / playbackSpeed);

  // Mobile detection after mount
  useEffect(() => {
    setIsMobile(window.innerWidth < 768);
    const handleResize = () => setIsMobile(window.innerWidth < 768);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  useEffect(() => {
    if (animatingCard) {
      x.set(position.x);
      y.set(position.y);
    }
  }, [animatingCard, x, y, position]);
  const emptyCategories = useMemo(() => ({
    'Very Important': [],
    'Important': [],
    'Quite Important': [],
    'Of Some Importance': [],
    'Not Important': []
  }), []);
  const getCurrentRoundCategories = useCallback(() => {
    const currentRoundData = rounds.find(r => r.roundNumber === currentRound);
    return currentRoundData?.availableCategories || emptyCategories;
  }, [currentRound, rounds, emptyCategories]);
  useEffect(() => {
    if (!sessionId) return;
    const loadRounds = async () => {
      try {
        const roundData = await getRoundsBySession(sessionId);
        const sortedRounds = roundData.sort((a, b) => a.roundNumber - b.roundNumber);
        setRounds(sortedRounds);
        if (sortedRounds.length > 0) {
          // Get all unique cards from all rounds
          const cards = new Set<Value>();
          sortedRounds.forEach(round => {
            Object.values(round.availableCategories).forEach(categoryCards => {
              categoryCards?.forEach(card => {
                cards.add(card);
              });
            });
          });
          const cardsArray = Array.from(cards);
          setAllCards(cardsArray);
          setReplayStateCards(cardsArray);

          // Set the first card
          const firstCommand = sortedRounds[0].commands[0];
          if (firstCommand) {
            const cardId = (firstCommand.payload as DropCommandPayload | MoveCommandPayload).cardId;
            const firstCard = cardsArray.find(card => card.id === cardId);
            if (firstCard) {
              setCurrentCard(firstCard);
            }
          }
        }
        resetCategories();
      } catch (error) {
        console.error('Failed to load rounds:', error);
      }
    };
    loadRounds();
  }, [sessionId, resetCategories, setReplayStateCards]);
  const getCommandDescription = useCallback((command: Command): string => {
    const payload = command.payload as DropCommandPayload | MoveCommandPayload;
    const card = allCards.find(c => c.id === payload.cardId);
    const cardTitle = card ? card.title : payload.cardId;
    if (command.type === 'DROP') {
      const dropPayload = payload as DropCommandPayload;
      return `Drop '${cardTitle}' to '${dropPayload.category}'`;
    } else if (command.type === 'MOVE') {
      const movePayload = payload as MoveCommandPayload;
      if (movePayload.fromCategory === movePayload.toCategory) {
        return `Move '${cardTitle}' within '${movePayload.fromCategory}'`;
      }
      return `Move '${cardTitle}' from '${movePayload.fromCategory}' to '${movePayload.toCategory}'`;
    }
    return `Command ${currentCommandIndex + 1}`;
  }, [allCards, currentCommandIndex]);
  const playNextCommand = useCallback(async () => {
    if (isRoundTransition) return;
    const currentRoundData = rounds.find(r => r.roundNumber === currentRound);
    if (!currentRoundData) return;
    if (currentCommandIndex >= currentRoundData.commands.length) {
      if (currentRound < rounds.length) {
        // Transition to the next round
        setIsRoundTransition(true);
        setIsPlaying(false);
        await new Promise(resolve => setTimeout(resolve, 1500)); // Pause before transitioning
        setCurrentRound(currentRound + 1);
        setCurrentCommandIndex(0);
        resetCategories();
        setIsRoundTransition(false);
        setIsPlaying(true);
        const nextRound = rounds.find(r => r.roundNumber === currentRound + 1);
        if (nextRound && nextRound.commands.length > 0) {
          const firstCommand = nextRound.commands[0];
          const cardId = (firstCommand.payload as DropCommandPayload | MoveCommandPayload).cardId;
          const nextCard = allCards.find(card => card.id === cardId);
          if (nextCard) {
            setCurrentCard(nextCard);
          }
          setCommandInfo({
            roundNumber: currentRound + 1,
            description: getCommandDescription(firstCommand)
          });
        }
        return;
      } else {
        setIsPlaying(false);
        return; // End of all rounds
      }
    }
    const command = currentRoundData.commands[currentCommandIndex];
    const payload = command.payload as DropCommandPayload | MoveCommandPayload;
    const cardId = payload.cardId;
    const cardToAnimate = allCards.find(card => card.id === cardId);
    if (!cardToAnimate) return;

    // Set the next command info if available
    const nextCommand = currentRoundData.commands[currentCommandIndex + 1];
    if (nextCommand) {
      setCommandInfo({
        roundNumber: currentRound,
        description: getCommandDescription(nextCommand)
      });
      const nextCardId = (nextCommand.payload as DropCommandPayload | MoveCommandPayload).cardId;
      const nextCard = allCards.find(card => card.id === nextCardId);
      if (nextCard) {
        setCurrentCard(nextCard);
      }
    } else if (currentCommandIndex + 1 === currentRoundData.commands.length && currentRound < rounds.length) {
      // Prepare for the transition indicating next round
      setCommandInfo({
        roundNumber: currentRound + 1,
        description: "Next round starting soon..."
      });
    }
    let sourceElement: Element | null;
    if (command.type === 'DROP') {
      //sourceElement = document.querySelector('.current-card-display');
      sourceElement = document.querySelector('[data-card-wrapper]');
    } else {
      const movePayload = payload as MoveCommandPayload;
      sourceElement = document.querySelector(`[data-category="${movePayload.fromCategory}"] [data-card-id="${cardId}"]`);
    }
    const targetCategory = command.type === 'DROP' ? (payload as DropCommandPayload).category : (payload as MoveCommandPayload).toCategory;
    const targetElement = document.querySelector(`[data-category="${targetCategory}"]`);
    if (sourceElement && targetElement) {
      const sourceRect = sourceElement.getBoundingClientRect();
      const targetRect = targetElement.getBoundingClientRect();
      const sourcePos = {
        x: sourceRect.left + sourceRect.width / 2,
        y: sourceRect.top + sourceRect.height / 2
      };
      const targetPos = {
        x: targetRect.left + targetRect.width / 2,
        y: targetRect.top + targetRect.height / 2
      };
      setAnimatingCard({
        value: cardToAnimate,
        sourcePos,
        targetPos
      });
      await new Promise<void>(resolve => {
        const animationDuration = 500 / playbackSpeed;
        setTimeout(() => {
          executeCommand(command);
          setAnimatingCard(null);
          resolve();
        }, animationDuration);
      });
    } else {
      executeCommand(command);
    }
    setCurrentCommandIndex(prev => prev + 1);
  }, [currentRound, currentCommandIndex, rounds, executeCommand, resetCategories, isRoundTransition, allCards, playbackSpeed, getCommandDescription, setAnimatingCard]);
  useEffect(() => {
    let timer: NodeJS.Timeout;
    if (isPlaying && rounds.length > 0 && !isAnimating && !isRoundTransition) {
      timer = setInterval(playNextCommand, 2000 / playbackSpeed);
    }
    return () => clearInterval(timer);
  }, [isPlaying, rounds, playbackSpeed, isAnimating, playNextCommand, isRoundTransition]);
  const handleReset = () => {
    setCurrentRound(1);
    setCurrentCommandIndex(0);
    setIsPlaying(false);
    resetCategories();
    setAnimatingCard(null);
    setCommandInfo(null);
    setCurrentCard(null);
    setIsRoundTransition(false);
  };

  // Don't render until we know if it's mobile or not
  if (isMobile === null) {
    return null;
  }
  return <div className="container mx-auto px-2 py-2 sm:px-4 sm:py-8" aria-label="Session replay viewer">
      <div className={`space-y-2 sm:space-y-4 ${isMobile ? 'h-screen flex flex-col' : ''}`}>
        <section className="bg-white rounded-lg shadow-lg p-2 sm:p-4" aria-label="Replay controls">
          <div className="flex flex-wrap items-center gap-2 sm:gap-4">
            <div className="flex gap-2">
              <button onClick={() => setIsPlaying(!isPlaying)} className="px-3 py-1.5 sm:px-4 sm:py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm sm:text-base" aria-label={isPlaying ? 'Pause replay' : 'Start replay'}>
                {isPlaying ? 'Pause' : 'Play'}
              </button>
              <button onClick={handleReset} className="px-3 py-1.5 sm:px-4 sm:py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm sm:text-base" aria-label="Reset replay to beginning">
                Reset
              </button>
            </div>

            <div className="flex items-center">
              <label htmlFor="playback-speed" className="sr-only">
                Playback speed
              </label>
              <select id="playback-speed" value={playbackSpeed} onChange={e => setPlaybackSpeed(Number(e.target.value))} className="px-3 py-1.5 sm:px-4 sm:py-2 border rounded bg-white text-sm sm:text-base" aria-label="Select playback speed">
                <option value={0.5}>0.5x Speed</option>
                <option value={1}>1x Speed</option>
                <option value={2}>2x Speed</option>
                <option value={4}>4x Speed</option>
              </select>
            </div>

            <div className="flex items-center text-sm sm:text-base" aria-live="polite" role="status">
              {!isPlaying && !commandInfo ? <span className="text-gray-600">
                  Click Play to start the replay
                </span> : commandInfo && <span>
                  <span className="font-semibold">Round {commandInfo.roundNumber}:</span>
                  {' '}{commandInfo.description}
                </span>}
            </div>
          </div>
        </section>

        <section className="relative h-32 sm:h-48" aria-label="Current card display">
          <div className="absolute left-1/2 transform -translate-x-1/2 current-card-display" data-card-wrapper aria-live="polite">
            {currentCard && !animatingCard && isPlaying && <AnimatedCard value={currentCard} columnIndex={undefined} onDrop={() => Promise.resolve()} currentCategory={undefined} />}
          </div>
        </section>

        <section aria-label="Card categories">
          {isMobile ? <div className="flex-1 min-h-0">
              <MobileReplayCategories categories={getCurrentRoundCategories()} aria-label="Mobile categories view" />
            </div> : <div className="grid grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4" role="grid" aria-label="Category grid">
              {Object.entries(getCurrentRoundCategories()).map(([title]) => <ReplayColumn key={title} title={title as CategoryName} cards={categories[title as CategoryName] || []} />)}
            </div>}
        </section>

        {animatingCard && <motion.div initial={{
        x: animatingCard.sourcePos.x,
        y: animatingCard.sourcePos.y
      }} animate={{
        x: animatingCard.targetPos.x,
        y: animatingCard.targetPos.y,
        transition: {
          type: "spring",
          stiffness: 100,
          damping: 15,
          mass: 1,
          duration: 0.75 / playbackSpeed
        }
      }} style={{
        position: 'fixed',
        transform: 'translate(-50%, -50%)',
        zIndex: 1000,
        pointerEvents: 'none'
      }} aria-hidden="true" // Hide animated card from screen readers
      >
            <AnimatedCard value={animatingCard.value} columnIndex={undefined} onDrop={() => Promise.resolve()} currentCategory={undefined} />
          </motion.div>}
      </div>
    </div>;
}

================
File: src/components/features/Replay/components/ReplayColumn/index.tsx
================
// src/components/Replay/components/ReplayColumn.tsx
import { Value, CategoryName } from "@/lib/types";
import {ReplayColumnProps} from '@/components/features/Replay/types';

export function ReplayColumn({
  title,
  cards
}: ReplayColumnProps) {
  const columnId = `replay-column-${title.toLowerCase().replace(/\s+/g, '-')}`;
  return <div data-category={title} className="bg-white rounded-lg shadow p-4" role="region" aria-labelledby={columnId}>
        <h3 id={columnId} className="text-lg font-semibold mb-4">
          {title}
          <span className="ml-2 text-sm text-gray-500" aria-label={`${cards.length} ${cards.length === 1 ? 'card' : 'cards'}`}>
            ({cards.length})
          </span>
        </h3>

        <div className="space-y-2" role="list" aria-label={`Values in ${title} category`}>
          {cards.map(card => <article key={card.id} data-card-id={card.id} className="bg-yellow-50 rounded-lg p-3 shadow" role="listitem">
              <div className="space-y-1" role="group" aria-labelledby={`card-title-${card.id}`}>
                <h4 id={`card-title-${card.id}`} className="font-medium">
                  {card.title}
                </h4>
                <p className="text-sm text-gray-600" aria-label={`Description: ${card.description}`}>
                  {card.description}
                </p>
              </div>
            </article>)}
        </div>

        {cards.length === 0 && <div className="text-gray-500 text-sm text-center py-4" role="status" aria-label={`No cards in ${title} category`}>
            No cards in this category
          </div>}
      </div>;
}

================
File: src/components/features/Replay/hooks/useCardAnimation.ts
================
import { useState, useEffect } from 'react';
import { Position } from "@/lib/types";
export const useCardAnimation = (sourcePosition: {
  x: number;
  y: number;
}, targetPosition: {
  x: number;
  y: number;
}, duration: number = 500) => {
  const [position, setPosition] = useState(sourcePosition);
  const [isAnimating, setIsAnimating] = useState(false);
  useEffect(() => {
    if (isAnimating) {
      const startTime = Date.now();
      const animate = () => {
        const currentTime = Date.now();
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation
        const eased = easeInOutCubic(progress);
        setPosition({
          x: sourcePosition.x + (targetPosition.x - sourcePosition.x) * eased,
          y: sourcePosition.y + (targetPosition.y - sourcePosition.y) * eased
        });
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          setIsAnimating(false);
        }
      };
      requestAnimationFrame(animate);
    }
  }, [isAnimating, sourcePosition, targetPosition, duration]);
  const startAnimation = () => {
    setIsAnimating(true);
  };
  return {
    position,
    isAnimating,
    startAnimation
  };
};

// Cubic easing function for smooth animation
const easeInOutCubic = (t: number): number => {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
};

================
File: src/components/features/Replay/hooks/useReplayState.ts
================
import { useState, useCallback } from 'react';
import { Value, Categories, CategoryName, Command, DropCommandPayload, MoveCommandPayload } from "@/lib/types";
import { initialCategories } from "@/components/features/Categories/constants/categories";
import {AnimatingCard} from '@/components/features/Replay/types';
export function useReplayState() {
  const [categories, setCategories] = useState<Categories>(initialCategories);
  const [animatingCard, setAnimatingCard] = useState<AnimatingCard | null>(null);
  const [allCards, setAllCards] = useState<Value[]>([]);
  const resetCategories = useCallback(() => {
    setCategories(initialCategories);
  }, []);
  const findCardById = useCallback((cardId: string): Value | undefined => {
    // Look in allCards first
    const card = allCards.find(c => c.id === cardId);
    if (card) return card;

    // If not found, look in categories
    for (const categoryCards of Object.values(categories)) {
      const found = categoryCards?.find(c => c.id === cardId);
      if (found) return found;
    }
    return undefined;
  }, [categories, allCards]);
  const executeCommand = useCallback((command: Command, availableCards?: Value[]) => {
    if (availableCards && allCards.length === 0) {
      setAllCards(availableCards);
    }
    if (command.type === 'DROP') {
      const {
        cardId,
        category
      } = command.payload as DropCommandPayload;
      const card = findCardById(cardId);
      if (!card) {
        console.warn(`Card with id ${cardId} not found`);
        return;
      }

      // Get source and target elements for animation
      const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
      const targetCategory = document.querySelector(`[data-category="${category}"]`);
      if (cardElement && targetCategory) {
        const sourceRect = cardElement.getBoundingClientRect();
        const targetRect = targetCategory.getBoundingClientRect();
        setAnimatingCard({
          value: card,
          sourcePos: {
            x: sourceRect.left + sourceRect.width / 2,
            y: sourceRect.top + sourceRect.height / 2
          },
          targetPos: {
            x: targetRect.left + targetRect.width / 2,
            y: targetRect.top + targetRect.height / 2
          }
        });
      }
      setCategories(prev => ({
        ...prev,
        [category]: [...(prev[category] || []), card]
      }));
    }
    if (command.type === 'MOVE') {
      const {
        cardId,
        fromCategory,
        toCategory
      } = command.payload as MoveCommandPayload;
      const card = findCardById(cardId);
      if (!card) {
        console.warn(`Card with id ${cardId} not found`);
        return;
      }

      // Get source and target elements for animation
      const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
      const targetCategory = document.querySelector(`[data-category="${toCategory}"]`);
      if (cardElement && targetCategory) {
        const sourceRect = cardElement.getBoundingClientRect();
        const targetRect = targetCategory.getBoundingClientRect();
        setAnimatingCard({
          value: card,
          sourcePos: {
            x: sourceRect.left + sourceRect.width / 2,
            y: sourceRect.top + sourceRect.height / 2
          },
          targetPos: {
            x: targetRect.left + targetRect.width / 2,
            y: targetRect.top + targetRect.height / 2
          }
        });
      }
      setCategories(prev => ({
        ...prev,
        [fromCategory]: prev[fromCategory]?.filter(c => c.id !== cardId) || [],
        [toCategory]: [...(prev[toCategory] || []), card]
      }));
    }
  }, [findCardById, allCards]);
  return {
    categories,
    animatingCard,
    executeCommand,
    resetCategories,
    setAnimatingCard,
    setAllCards
  };
}

================
File: src/components/features/Replay/types.ts
================
import { Value, Categories, CategoryName } from "@/lib/types";

export interface ReplayColumnProps {
  title: CategoryName;
  cards: Value[];
}

export interface MobileReplayCategoriesProps {
  categories: Categories;
}

export interface AnimatingCard {
  value: Value;
  sourcePos: { x: number; y: number };
  targetPos: { x: number; y: number };
}

export interface CommandInfo {
  roundNumber: number;
  description: string;
}

================
File: src/components/features/Round/CategoryGrid.tsx
================
// src/components/Round/CategoryGrid.tsx
import CategoryColumn from "@/components/features/Categories/components/CategoryColumn";
import { CategoryGridProps } from '@/components/features/Round/types';
import { CategoryName, Value } from "@/lib/types";

export function CategoryGrid({
  categories,
  onDrop,
  onMoveWithinCategory,
  onMoveBetweenCategories
}: CategoryGridProps) {
  const categoryNames = Object.keys(categories) as CategoryName[];
  return <section aria-label="Value Categories Grid" className="w-full flex justify-center px-4">
      <div className="grid w-full max-w-[1600px]" style={{
      gridTemplateColumns: `repeat(${categoryNames.length}, minmax(300px, 1fr))`,
      gap: '1.5rem' // Reduced gap to allow more space
    }} role="grid" aria-label="Categories grid layout">
        {(Object.entries(categories) as [CategoryName, Value[]][]).map(([title, cards], index) => <CategoryColumn key={title} title={title} cards={cards} onDrop={onDrop} onMoveWithinCategory={(fromIndex, toIndex) => onMoveWithinCategory(title, fromIndex, toIndex)} onMoveBetweenCategories={onMoveBetweenCategories} columnIndex={index} />)}
      </div>
    </section>;
}

================
File: src/components/features/Round/components/Mobile/MobileCardControls.tsx
================
import { 
  ChevronUpIcon, 
  ChevronDownIcon,
  ArrowUpIcon,
  ArrowDownIcon
} from '@heroicons/react/24/solid';

import { MobileCardControlsProps } from '@/components/features/Round/types';

export function MobileCardControls({ 
  canMoveUp, 
  canMoveDown, 
  onMoveUp, 
  onMoveDown,
  canMoveToPrevCategory,
  canMoveToNextCategory,
  onMoveToPrevCategory,
  onMoveToNextCategory
}: MobileCardControlsProps) {
  return (
    <div className="flex justify-end gap-2 mt-2 px-2">
      <div className="flex flex-col gap-1">
        {canMoveToPrevCategory && (
          <button
            onClick={onMoveToPrevCategory}
            className="p-2 rounded-full bg-blue-100 hover:bg-blue-200 text-blue-800"
            aria-label="Move to previous category"
          >
            <ArrowUpIcon className="w-5 h-5" />
          </button>
        )}
      </div>
      <div className="flex flex-col gap-1">
        {canMoveUp && (
          <button
            onClick={onMoveUp}
            className="p-2 rounded-full bg-gray-100 hover:bg-gray-200"
            aria-label="Move up within category"
          >
            <ChevronUpIcon className="w-5 h-5" />
          </button>
        )}
        {canMoveDown && (
          <button
            onClick={onMoveDown}
            className="p-2 rounded-full bg-gray-100 hover:bg-gray-200"
            aria-label="Move down within category"
          >
            <ChevronDownIcon className="w-5 h-5" />
          </button>
        )}
      </div>
      <div className="flex flex-col gap-1">
        {canMoveToNextCategory && (
          <button
            onClick={onMoveToNextCategory}
            className="p-2 rounded-full bg-blue-100 hover:bg-blue-200 text-blue-800"
            aria-label="Move to next category"
          >
            <ArrowDownIcon className="w-5 h-5" />
          </button>
        )}
      </div>
    </div>
  );
}

================
File: src/components/features/Round/components/Mobile/MobileCategoryRow.tsx
================
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { CategoryName, Value } from "@/lib/types";
import { ChevronDownIcon, ChevronUpIcon, ArrowUpIcon, ArrowDownIcon } from '@heroicons/react/24/solid';
import { useState } from 'react';
import { MobileCategoryRowProps } from '@/components/features/Round/types';

export function MobileCategoryRow({
  category,
  cards,
  availableCategories,
  isActive,
  isExpanded,
  onCategoryTap,
  onCategorySelect,
  showingCardSelection,
  onMoveWithinCategory,
  onMoveBetweenCategories,
  lastDroppedCategory
}: MobileCategoryRowProps) {
  const currentCategoryIndex = availableCategories.indexOf(category);
  const categoryId = `category-${category.toLowerCase().replace(/\s+/g, '-')}`;
  const [expandedCards, setExpandedCards] = useState<Set<string>>(new Set());
  const toggleCardExpansion = (cardId: string, event: React.MouseEvent) => {
    event.stopPropagation();
    const newExpanded = new Set(expandedCards);
    if (newExpanded.has(cardId)) {
      newExpanded.delete(cardId);
    } else {
      newExpanded.add(cardId);
    }
    setExpandedCards(newExpanded);
  };
  return <motion.div layout className={`
    rounded-lg 
    transition-all duration-300
    border-2 
    ${isActive || lastDroppedCategory === category ? 'bg-green-50' : 'bg-white'}
    ${showingCardSelection ? 'border-black shadow-md z-50 cursor-pointer' : 'border-transparent hover:border-gray-200 z-0'}
  `} role="region" aria-labelledby={categoryId}>
      <button onClick={() => showingCardSelection ? onCategorySelect(category) : onCategoryTap(category)} className="w-full p-4" aria-expanded={isExpanded} aria-controls={`${categoryId}-content`} aria-label={`${category} category with ${cards.length} cards${showingCardSelection ? '. Tap to select' : ''}`}>
        <div className="flex items-center justify-between">
          <h3 id={categoryId} className="font-medium">
            {category}
          </h3>
          <span className="bg-gray-200 px-2 py-1 rounded-full text-sm" aria-label={`${cards.length} cards`}>
            {cards.length}
          </span>
        </div>
      </button>

      <AnimatePresence>
        {isExpanded && !showingCardSelection && cards.length > 0 && <motion.div id={`${categoryId}-content`} initial={{
        height: 0,
        opacity: 0
      }} animate={{
        height: 'auto',
        opacity: 1
      }} exit={{
        height: 0,
        opacity: 0
      }} className="overflow-hidden" role="list" aria-label={`Cards in ${category}`}>
            <div className="space-y-2 px-2 pb-2">
              {cards.map((card, index) => <div key={card.id} className="bg-yellow-100 rounded-lg shadow-sm" role="listitem">
                  <div className="flex items-center justify-between p-2 gap-2 border-b border-yellow-200">
                    {/* Card Title and Expand Button */}
                    <button onClick={e => toggleCardExpansion(card.id, e)} className="flex items-center gap-2 flex-1 text-left" aria-expanded={expandedCards.has(card.id)} aria-label={`${card.title}. Click to ${expandedCards.has(card.id) ? 'collapse' : 'expand'}`}>
                      <ChevronDownIcon className={`w-4 h-4 text-yellow-700 transition-transform flex-shrink-0
                          ${expandedCards.has(card.id) ? 'rotate-180' : ''}
                        `} aria-hidden="true" />
                      <span className="text-sm font-medium text-yellow-900 truncate">
                        {card.title}
                      </span>
                    </button>

                    {/* Controls */}
                    <div className="flex items-center gap-3 flex-shrink-0">
                      {/* Category Movement Controls */}
                      <div className="flex items-center gap-1 border-r border-yellow-200 pr-3">
                        {currentCategoryIndex > 0 && <button onClick={() => onMoveBetweenCategories?.(card, category, availableCategories[currentCategoryIndex - 1])} className="p-1.5 rounded-full bg-blue-100 hover:bg-blue-200 text-blue-800" aria-label={`Move to ${availableCategories[currentCategoryIndex - 1]}`}>
                            <ArrowUpIcon className="w-4 h-4" />
                          </button>}
                        {currentCategoryIndex < availableCategories.length - 1 && <button onClick={() => onMoveBetweenCategories?.(card, category, availableCategories[currentCategoryIndex + 1])} className="p-1.5 rounded-full bg-blue-100 hover:bg-blue-200 text-blue-800" aria-label={`Move to ${availableCategories[currentCategoryIndex + 1]}`}>
                            <ArrowDownIcon className="w-4 h-4" />
                          </button>}
                      </div>

                      {/* Position Movement Controls */}
                      <div className="flex items-center gap-1">
                        {index > 0 && <button onClick={() => onMoveWithinCategory?.(index, index - 1)} className="p-1.5 rounded-full bg-gray-100 hover:bg-gray-200" aria-label="Move up within category">
                            <ChevronUpIcon className="w-4 h-4" />
                          </button>}
                        {index < cards.length - 1 && <button onClick={() => onMoveWithinCategory?.(index, index + 1)} className="p-1.5 rounded-full bg-gray-100 hover:bg-gray-200" aria-label="Move down within category">
                            <ChevronDownIcon className="w-4 h-4" />
                          </button>}
                      </div>
                    </div>
                  </div>

                  {/* Expandable Description */}
                  <AnimatePresence>
                    {expandedCards.has(card.id) && <motion.div initial={{
                height: 0,
                opacity: 0
              }} animate={{
                height: 'auto',
                opacity: 1
              }} exit={{
                height: 0,
                opacity: 0
              }} className="overflow-hidden">
                        <div className="px-4 pb-3 text-sm text-yellow-800">
                          {card.description}
                        </div>
                      </motion.div>}
                  </AnimatePresence>
                </div>)}
            </div>
          </motion.div>}
      </AnimatePresence>
    </motion.div>;
}

================
File: src/components/features/Round/components/Mobile/MobileSelectionOverlay.tsx
================
import { motion, AnimatePresence } from 'framer-motion';
import { MobileSelectionOverlayProps} from '@/components/features/Round/types';


export function MobileSelectionOverlay({ isVisible }: MobileSelectionOverlayProps) {
  return (
    <AnimatePresence>
      {isVisible && (
        <>
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
            className="fixed inset-0 bg-black bg-opacity-50 z-50"
          />
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.2, delay: 0.1 }}
            className="fixed top-4 left-1/2 transform -translate-x-1/2 text-white text-lg font-medium z-50 text-center pointer-events-none px-4 w-full"
          >
            Tap a category to place card
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
}

================
File: src/components/features/Round/components/MobileCardView.tsx
================
// src/components/Round/components/MobileCardView.tsx
import React from 'react';
import { Value, CategoryName, Categories } from "@/lib/types";
import { Card } from "@/components/features/Cards/components";
import { MobileCardViewProps} from '@/components/features/Round/types';

export const MobileCardView: React.FC<MobileCardViewProps> = ({
  cards,
  categorizedCards,
  onCardPlace
}) => {
  return <div className="fixed inset-0 bg-white z-50 overflow-auto p-4" role="dialog" aria-label="Value cards selection">
      <div className="space-y-4" role="list" aria-label="Available value cards">
        {cards.map(card => <div key={card.id} className="p-2" role="listitem">
            <Card value={card} aria-label={`Value card: ${card.title}`} />
          </div>)}
      </div>
      
      {cards.length === 0 && <div className="text-center text-gray-600 py-4" role="status" aria-live="polite">
          No cards available
        </div>}
    </div>;
};

================
File: src/components/features/Round/components/MobileCategoryList.tsx
================
import { useState } from 'react';
import { Categories, CategoryName, Value } from "@/lib/types";
import { MobileCategoryRow } from './Mobile/MobileCategoryRow';
import { MobileCategoryListProps} from '@/components/features/Round/types';

export function MobileCategoryList({
  categories,
  activeDropZone,
  onDrop,
  onMoveWithinCategory,
  onMoveBetweenCategories,
  selectedCard,
  onCardSelect
}: MobileCategoryListProps) {
  const [expandedCategory, setExpandedCategory] = useState<CategoryName | null>(null);
  const categoryNames = Object.keys(categories) as CategoryName[];
  const [lastDroppedCategory, setLastDroppedCategory] = useState<CategoryName | null>(null);
  const handleCategorySelect = (category: CategoryName) => {
    if (selectedCard) {
      setLastDroppedCategory(category);
      onDrop(selectedCard, category);
      onCardSelect(null);
      // Reset the highlight after animation
      setTimeout(() => {
        setLastDroppedCategory(null);
      }, 1000); // 1 second total for the animation
    }
  };
  const handleCategoryTap = (category: CategoryName) => {
    setExpandedCategory(expandedCategory === category ? null : category);
  };
  return <div className="h-full flex flex-col">
      <div className="flex-1 overflow-y-auto px-1" // Changed from -mx-2 to px-3
    role="region" aria-label="Categories list">
        <div className="space-y-2"> {/* Removed px-2 since padding is now on parent */}
          {categoryNames.map(category => <div key={category}>
              <MobileCategoryRow category={category} cards={categories[category] ?? []} availableCategories={categoryNames} isActive={activeDropZone === category} isExpanded={expandedCategory === category} onCategoryTap={handleCategoryTap} onCategorySelect={handleCategorySelect} showingCardSelection={!!selectedCard} onMoveWithinCategory={(fromIndex, toIndex) => onMoveWithinCategory(category, fromIndex, toIndex)} onMoveBetweenCategories={onMoveBetweenCategories} lastDroppedCategory={lastDroppedCategory} />
            </div>)}
        </div>
      </div>
    </div>;
}

================
File: src/components/features/Round/components/StatusMessage.tsx
================
// src/components/Round/components/StatusMessage.tsx
'use client';

import { ReactNode } from 'react';
import { StatusMessageProps } from '@/components/features/Round/types';
import { useMobile } from "@/lib/contexts/MobileContext";
export const StatusMessage = ({
  status,
  isNearingCompletion,
  hasTooManyImportantCards,
  hasNotEnoughImportantCards,
  hasEnoughCards,
  targetCoreValues,
  canProceedToNextRound,
  remainingCards,
  showDetails = true,
  setShowDetails
}: StatusMessageProps): ReactNode => {
  const {
    isMobile
  } = useMobile();
  const handleButtonClick = () => {
    if (setShowDetails) {
      setShowDetails(!showDetails); // Toggle the details visibility
    }
  };
  const messageContent = <div role="status">
      <p className={`${isMobile ? 'text-sm' : 'text-base'} font-medium leading-tight`} aria-live="polite">
        {status.text}
      </p>
      {isNearingCompletion && (hasTooManyImportantCards || hasNotEnoughImportantCards) && <p className={`mt-1 ${isMobile ? 'text-xs' : 'text-sm'} leading-tight`} aria-live="polite">
          You need exactly {targetCoreValues} values in Very Important
        </p>}
      {!hasEnoughCards && <p className={`mt-1 ${isMobile ? 'text-xs' : 'text-sm'} leading-tight`} aria-live="polite">
          You must keep at least {targetCoreValues} values outside of Not Important
        </p>}
    </div>;
  if (isMobile) {
    return <div className="relative" role="status" aria-live="polite">
        <button onClick={handleButtonClick} className={`
            rounded-full p-2 flex items-center justify-center
            ${!canProceedToNextRound && remainingCards.length === 0 ? 'bg-red-100 text-red-800' : status.type === 'warning' ? 'bg-yellow-100 text-yellow-800' : status.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}
            focus:outline-none focus:ring-2 focus:ring-offset-2
            ${status.type === 'warning' ? 'focus:ring-yellow-500' : status.type === 'success' ? 'focus:ring-green-500' : 'focus:ring-blue-500'}
          `} aria-expanded={showDetails} aria-label={`Game status: ${status.text}. ${showDetails ? 'Hide details' : 'Show details'}`}>
          <span aria-hidden="true">
            {status.type === 'warning' ? '⚠️' : status.type === 'success' ? '✅' : 'ℹ️'}
          </span>
          <span className="sr-only">{status.text}</span>
        </button>

        {showDetails && <div className="absolute right-0 top-full mt-2 z-50 w-64 p-4 rounded-lg shadow-lg bg-white border" role="tooltip" aria-label="Status details">
            {messageContent}
          </div>}
      </div>;
  }

  // Desktop version - always show
  return <div className={`
        relative
        p-3 sm:p-4
        min-h-[5rem]
        h-full
        w-full
        flex flex-col justify-center 
        rounded-lg 
        overflow-hidden
        ${!canProceedToNextRound && remainingCards.length === 0 ? 'bg-red-50 text-red-800' : status.type === 'warning' ? 'bg-yellow-100 text-yellow-800' : status.type === 'success' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}
      `} role="status" aria-live="polite">
      <div className="space-y-1">
        {messageContent}
      </div>
    </div>;
};

================
File: src/components/features/Round/hooks/useMobileInteractions.ts
================
import { useState, useCallback } from 'react';
import { CategoryName, Value } from "@/lib/types";
import { logStateUpdate } from "@/lib/utils";

export function useMobileInteractions() {
  const [expandedCategory, setExpandedCategory] = useState<CategoryName | null>(null);
  const [activeDropZone, setActiveDropZone] = useState<CategoryName | null>(null);
  const handleExpand = useCallback((category: CategoryName) => {
    logStateUpdate('handleMobileExpand', {
      category
    }, 'MobileInteractions');
    setExpandedCategory(category);
  }, []);
  const handleClose = useCallback(() => {
    logStateUpdate('handleMobileClose', {}, 'MobileInteractions');
    setExpandedCategory(null);
  }, []);
  const handleDropWithZone = useCallback((card: Value, category: CategoryName) => {
    logStateUpdate('handleMobileDropWithZone', {
      card,
      category
    }, 'MobileInteractions');
    setActiveDropZone(category);

    // Clear the active zone after a short delay
    setTimeout(() => {
      setActiveDropZone(null);
    }, 500);
    return {
      category
    };
  }, []);
  return {
    expandedCategory,
    activeDropZone,
    handleExpand,
    handleClose,
    handleDropWithZone
  };
}

================
File: src/components/features/Round/hooks/useMobileView.ts
================
import { useState } from 'react';
import { CategoryName, Value } from "@/lib/types";
export function useMobileView() {
  const [expandedCategory, setExpandedCategory] = useState<CategoryName | null>(null);
  const [showCategorySelection, setShowCategorySelection] = useState(false);
  const [selectedCard, setSelectedCard] = useState<Value | null>(null);
  const handleExpandCategory = (category: CategoryName) => {
    setExpandedCategory(category === expandedCategory ? null : category);
  };
  const handleCloseExpanded = () => {
    setExpandedCategory(null);
  };
  const handleShowCategorySelection = (card: Value) => {
    setSelectedCard(card);
    setShowCategorySelection(true);
  };
  const handleCloseCategorySelection = () => {
    setShowCategorySelection(false);
    setSelectedCard(null);
  };
  return {
    expandedCategory,
    showCategorySelection,
    selectedCard,
    handleExpandCategory,
    handleCloseExpanded,
    handleShowCategorySelection,
    handleCloseCategorySelection
  };
}

================
File: src/components/features/Round/hooks/useRoundHandlers.ts
================
import { useCallback, useEffect } from 'react';
import { CategoryName, Categories, Value, Command } from "@/lib/types";
import { MoveCommand } from "@/components/features/Game/commands/MoveCommand";
import { DropCommand } from "@/components/features/Game/commands/DropCommand";
import { saveRound } from "@/lib/db/indexedDB";
import { logEffect, logStateUpdate } from "@/lib/utils";
export const useRoundHandlers = (categories: Categories, setCategories: (categories: Categories) => void, remainingCards: Value[], setRemainingCards: (cards: Value[]) => void, validCategories: CategoryName[], activeCategories: CategoryName[], sessionId: string | null, roundNumber: number, currentRoundCommands: Command[], addCommand: (command: Command) => Promise<void>, clearCommands: () => void, targetCoreValues: number, setRoundNumber: (round: number) => void, setShowResults: (show: boolean) => void, setShowStatusDetails: (isFirst: boolean) => void) => {
  useEffect(() => {
    logEffect('categories effect in useRoundHandlers', [categories]);
  }, [categories]);
  useEffect(() => {
    console.log('Commands updated:', currentRoundCommands);
  }, [currentRoundCommands]);

  // in useRoundHandlers.ts
  const saveRoundData = useCallback(async (command: Command) => {
    if (!sessionId) return;
    try {
      // Only pass the visible categories
      const visibleCats = Object.fromEntries(Object.entries(categories).filter(([category]) => validCategories.includes(category as CategoryName))) as Categories;
      await saveRound(sessionId, roundNumber, [...currentRoundCommands, command], visibleCats);
    } catch (error) {
      console.error('Failed to save round data:', error);
    }
  }, [sessionId, roundNumber, currentRoundCommands, categories, validCategories]);
  const handleDrop = useCallback(async (value: Value, category: CategoryName): Promise<void> => {
    if (!validCategories.includes(category)) return;
    const card = remainingCards.find((c: Value) => c.title === value.title);
    if (!card) return;
    const command = new DropCommand(value, category);
    const updatedCategories = {
      ...categories
    };
    updatedCategories[category] = [...(categories[category] || []), card];
    setCategories(updatedCategories);
    setRemainingCards(remainingCards.filter((c: Value) => c.title !== value.title));
    await addCommand(command);
    await saveRoundData(command);
  }, [remainingCards, categories, validCategories, setCategories, setRemainingCards, addCommand, saveRoundData]);
  const handleMoveCard = useCallback(async (category: CategoryName, fromIndex: number, toIndex: number): Promise<void> => {
    // Debug logging
    console.log('handleMoveCard called:', {
      category,
      fromIndex,
      toIndex
    });

    // Early returns with logging
    if (!validCategories.includes(category)) {
      console.log('Invalid category, returning');
      return;
    }
    if (fromIndex === toIndex) {
      console.log('Same index, returning');
      return;
    }
    const categoryCards = categories[category] || [];
    if (!categoryCards[fromIndex]) {
      console.log('No card at fromIndex, returning');
      return;
    }

    // Get the card we're moving
    const cardToMove = categoryCards[fromIndex];

    // Create a new categories object with the updated order
    const updatedCategories = {
      ...categories
    };
    const newCards = [...categoryCards];
    newCards.splice(fromIndex, 1);
    newCards.splice(toIndex, 0, cardToMove);
    updatedCategories[category] = newCards;

    // Create single command for this move
    const command = new MoveCommand(cardToMove, category, category, fromIndex, toIndex);

    // Update state and save in a single operation
    try {
      setCategories(updatedCategories);
      await addCommand(command);
      await saveRoundData(command);
      console.log('Move completed successfully:', {
        card: cardToMove,
        from: fromIndex,
        to: toIndex,
        category
      });
    } catch (error) {
      console.error('Error in handleMoveCard:', error);
    }
  }, [categories, validCategories, setCategories, addCommand, saveRoundData]);
  const handleMoveBetweenCategories = useCallback(async (value: Value, fromCategory: CategoryName, toCategory: CategoryName): Promise<void> => {
    if (!activeCategories.includes(fromCategory)) return;
    if (!validCategories.includes(toCategory) && !activeCategories.includes(toCategory)) return;
    // Set first interaction to false when a card is dropped

    const fromCards = categories[fromCategory] || [];
    const toCards = categories[toCategory] || [];
    if (!fromCards.some(card => card.title === value.title)) return;
    const command = new MoveCommand(value, fromCategory, toCategory);
    const updatedCategories = {
      ...categories
    };
    updatedCategories[fromCategory] = fromCards.filter(card => card.title !== value.title);
    updatedCategories[toCategory] = [...toCards, value];
    setCategories(updatedCategories);
    await addCommand(command);
    await saveRoundData(command);
  }, [categories, validCategories, activeCategories, setCategories, addCommand, saveRoundData]);
  return {
    handleMoveCard,
    handleDrop,
    handleMoveBetweenCategories,
    saveRoundData
  };
};

================
File: src/components/features/Round/hooks/useRoundState.ts
================
import { useMemo } from 'react';
import { Categories, CategoryName, Value } from "@/lib/types";
export const useRoundState = (categories: Categories, remainingCards: Value[], targetCoreValues: number) => {
  const hasTargetCoreValuesInVeryImportant = categories['Very Important']?.length === targetCoreValues;

  // Calculate active cards (excluding Not Important)
  const activeCards = Object.entries(categories).filter(([category]) => category !== 'Not Important').reduce((sum, [_, cards]) => sum + (cards?.length || 0), 0);

  // Calculate total active including remaining cards
  const totalActiveCards = activeCards + remainingCards.length;
  const validCategories = useMemo(() => {
    return Object.keys(categories).filter(category => categories[category] !== undefined) as CategoryName[];
  }, [categories]);
  const activeCategories = useMemo(() => {
    return Object.entries(categories).filter(([_, cards]) => cards && cards.length > 0).map(([category]) => category as CategoryName);
  }, [categories]);
  const visibleCategories = useMemo(() => {
    const allCategories = [...validCategories, ...activeCategories].filter((category, index, self) => self.indexOf(category) === index);
    return allCategories.reduce((acc, category) => {
      acc[category] = categories[category] || [];
      return acc;
    }, {} as Categories);
  }, [validCategories, activeCategories, categories]);
  const veryImportantCount = categories['Very Important']?.length || 0;
  const notImportantCount = categories['Not Important']?.length || 0;
  const isNearingCompletion = validCategories.length === 2;
  const hasEnoughCards = totalActiveCards >= targetCoreValues;
  const hasMinimumNotImportant = notImportantCount >= 1;
  const hasTooManyImportantCards = isNearingCompletion && veryImportantCount > targetCoreValues;
  const hasNotEnoughImportantCards = isNearingCompletion && veryImportantCount < targetCoreValues;

  // New calculation for found core values
  const hasFoundCoreValues = Object.entries(categories).some(([category, cards]) => category !== 'Not Important' && cards?.length === targetCoreValues);
  const isEndGameReady = isNearingCompletion && veryImportantCount === targetCoreValues && totalActiveCards === targetCoreValues && hasMinimumNotImportant || hasFoundCoreValues || hasTargetCoreValuesInVeryImportant;
  return {
    activeCards,
    totalActiveCards,
    validCategories,
    activeCategories,
    visibleCategories,
    veryImportantCount,
    notImportantCount,
    isNearingCompletion,
    hasEnoughCards,
    hasMinimumNotImportant,
    hasTooManyImportantCards,
    hasNotEnoughImportantCards,
    isEndGameReady,
    hasFoundCoreValues,
    hasTargetCoreValuesInVeryImportant,
    categories
  };
};

================
File: src/components/features/Round/hooks/useRoundStatus.ts
================
// src/components/Round/hooks/useRoundStatus.ts
import { useCallback } from 'react';
import { useMobile } from '@/lib/contexts/MobileContext';
import {StatusState, Status, StatusType} from '@/components/features/Round/types';

export const useRoundStatus = (state: StatusState) => {
  const {
    isMobile
  } = useMobile();
  return useCallback((): Status => {
    if (state.remainingCards.length > 0) {
      if (isMobile) {
        return {
          text: `Tap the yellow card to select it, then tap a category to place it`,
          type: 'info',
          isEndGame: false
        };
      }
      return {
        text: `Drag the remaining ${state.remainingCards.length === 1 ? "" : state.remainingCards.length} ${state.remainingCards.length === 1 ? "value" : "values"} to a category`,
        type: 'info',
        isEndGame: false
      };
    }
    if (!state.hasMinimumNotImportant) {
      return {
        text: 'You need to place at least one value in Not Important before you can continue',
        type: 'warning',
        isEndGame: false
      };
    }
    const activeCardsCount = Object.entries(state.categories).filter(([category]) => category !== 'Not Important').reduce((sum, [_, cards]) => sum + (cards?.length || 0), 0);
    if (activeCardsCount < state.targetCoreValues) {
      return {
        text: `You need at least ${state.targetCoreValues} values outside of Not Important to continue`,
        type: 'warning',
        isEndGame: false
      };
    }
    if (state.veryImportantCount === state.targetCoreValues) {
      return {
        text: 'Perfect! Click End Game to complete the exercise.',
        type: 'success',
        isEndGame: true
      };
    }
    return {
      text: 'You can continue to the next round or keep refining your choices',
      type: 'info',
      isEndGame: false
    };
  }, [state, isMobile]);
};

================
File: src/components/features/Round/hooks/useRoundValidation.ts
================
import { useCallback } from 'react';
import { Value, Categories } from "@/lib/types";
export type ValidationState = {
  remainingCards: Value[];
  hasMinimumNotImportant: boolean;
  hasEnoughCards: boolean;
  isNearingCompletion: boolean;
  veryImportantCount: number;
  targetCoreValues: number;
  totalActiveCards: number;
  categories: Categories;
};
export const useRoundValidation = (state: ValidationState) => {
  return () => {
    // Can't proceed if there are remaining cards
    if (state.remainingCards.length > 0) {
      return false;
    }

    // Must have at least one card in Not Important
    if (!state.hasMinimumNotImportant) {
      return false;
    }

    // Calculate total cards in non-Not Important categories
    const activeCardsCount = Object.entries(state.categories).filter(([category]) => category !== 'Not Important').reduce((sum, [_, cards]) => sum + (cards?.length || 0), 0);

    // Allow next round if we have enough active cards for the target
    return activeCardsCount >= state.targetCoreValues;
  };
};

================
File: src/components/features/Round/index.ts
================
export { default as RoundUI } from './RoundUI';

================
File: src/components/features/Round/RoundActions.tsx
================
// src/components/Round/RoundActions.tsx
import { CategoryName } from "@/lib/types";
import { Card } from "@/components/features/Cards/components";
import { RoundActionsPropsWithActiveZone } from './types';
import { useMobile } from "@/lib/contexts/MobileContext";

export function RoundActions({
  remainingCards,
  canProceedToNextRound,
  onNextRound,
  onDrop,
  isEndGame,
  onActiveDropZoneChange,
  selectedMobileCard,
  onMobileCardSelect,
  setShowDetails
}: RoundActionsPropsWithActiveZone) {
  const {
    isMobile
  } = useMobile();
  const currentCard = remainingCards.length > 0 ? remainingCards[0] : null;
  const handleCardClick = () => {
    if (isMobile) {
      setShowDetails?.(false);
      onMobileCardSelect?.(currentCard);
    }
  };
  if (!currentCard) {
    return <div className="h-24 sm:h-48 flex items-center justify-center" role="region" aria-label="Round progression">
        <div className="flex justify-center mt-4">
          <button onClick={onNextRound} disabled={!canProceedToNextRound} className={`
              ${isMobile ? 'px-3 py-1.5 text-sm' : 'px-6 py-2 text-base'}
              rounded-md text-white font-medium
              ${canProceedToNextRound ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-400 cursor-not-allowed'}
              focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
            `} aria-label={isEndGame ? 'Complete exercise' : 'Proceed to next round'}>
            {isEndGame ? 'Finish' : 'Next Round'}
          </button>
        </div>
      </div>;
  }
  if (isMobile) {
    return <div className="flex flex-col items-center h-32 mb-2" role="region" aria-label="Current value card">
        <div className={`
            flex items-center justify-center cursor-pointer
            transform transition-all duration-200
            scale-[0.7]
          `} role="button" tabIndex={0} onClick={handleCardClick} onKeyPress={e => {
        if (e.key === 'Enter' || e.key === ' ') {
          handleCardClick();
        }
      }} aria-label={`${selectedMobileCard ? 'Selected card' : 'Select card'}: ${currentCard.title}`}>
          <Card value={currentCard} onClick={handleCardClick} selectedMobileCard={!!selectedMobileCard} // Add this line
        />
        </div>
      </div>;
  }
  return <div className="flex flex-col items-center h-48" role="region" aria-label="Current value card">
      <div className="flex items-center justify-center h-full" aria-live="polite">
        <Card value={currentCard} onDrop={value => onDrop(value, value.sourceCategory as CategoryName)} onActiveDropZoneChange={onActiveDropZoneChange} />
      </div>
    </div>;
}

================
File: src/components/features/Round/RoundHeader.tsx
================
import { RoundHeaderProps } from '@/features/Round/types';


export function RoundHeader({
  targetCoreValues,
  roundNumber,
  remainingCardsCount
}: RoundHeaderProps) {
  return (
    <div className="container mx-auto">
      <div className="grid grid-cols-3 gap-2 sm:gap-4 p-2 sm:p-4">
        {/* Both Mobile and Desktop use the same lozenge style */}
        <div>
          <div className="bg-blue-50 rounded-full px-3 py-1.5 text-center shadow-sm">
            <h2 className="text-xs sm:text-sm font-semibold text-blue-700 uppercase tracking-wide">
              Target
            </h2>
            <p className="text-lg sm:text-2xl font-bold text-blue-900">
              {targetCoreValues}
            </p>
          </div>
        </div>
        <div>
          <div className="bg-purple-50 rounded-full px-3 py-1.5 text-center shadow-sm">
            <h2 className="text-xs sm:text-sm font-semibold text-purple-700 uppercase tracking-wide">
              Round
            </h2>
            <p className="text-lg sm:text-2xl font-bold text-purple-900">
              {roundNumber}
            </p>
          </div>
        </div>
        <div>
          <div className="bg-green-50 rounded-full px-3 py-1.5 text-center shadow-sm">
            <h2 className="text-xs sm:text-sm font-semibold text-green-700 uppercase tracking-wide">
              Cards
            </h2>
            <p className="text-lg sm:text-2xl font-bold text-green-900">
              {remainingCardsCount}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/features/Round/RoundUI.tsx
================
'use client';

import { useState, useEffect, memo, useMemo, useCallback } from 'react';
import { saveRound, updateSession, saveCompletedSession } from "@/lib/db/indexedDB";
import Results from "@/components/features/Game/components/Results";
import { useSession } from "@/components/features/Game/hooks/useSession";
import { useGameState } from "@/components/features/Game/hooks/useGameState";
import { useCommands } from "@/components/features/Game/hooks/useCommands";
import { RoundHeader } from './RoundHeader';
import { RoundActions } from './RoundActions';
import { CategoryGrid } from './CategoryGrid';
import { getImportantCards } from "@/components/features/Categories/utils/categoryUtils";
import { useRoundState } from './hooks/useRoundState';
import { useRoundHandlers } from './hooks/useRoundHandlers';
import { useRoundValidation } from './hooks/useRoundValidation';
import { useRoundStatus } from './hooks/useRoundStatus';
import { getRandomValues } from "@/components/features/Game/utils";
import { Categories, CategoryName, Value, ValueWithReason } from "@/lib/types";
import { StatusMessage } from './components/StatusMessage';
import { getCategoriesForRound } from "@/components/features/Categories/utils/categoryUtils";
import { MobileCategoryList } from './components/MobileCategoryList';
import { CoreValueReasoning } from "@/components/features/Game/components/CoreValueReasoning";
import { logRender, logStateUpdate, logEffect } from "@/lib/utils";

import { useMobile } from "@/lib/contexts/MobileContext";
import { Card } from "@/components/features/Cards/components";
import { motion } from 'framer-motion';
import { MoveCommand } from "@/components/features/Game/commands/MoveCommand";

const RoundUI = memo(function RoundUI() {
  logRender('RoundUI');

  // State
  const [activeDropZone, setActiveDropZone] = useState<CategoryName | null>(null);
  const [showResults, setShowResults] = useState<boolean>(false);
  const [shouldEndGame, setShouldEndGame] = useState<boolean>(false);
  const [showReasoning, setShowReasoning] = useState<boolean>(false);
  const [finalValuesWithoutReasons, setFinalValuesWithoutReasons] = useState<Value[]>([]);
  const [selectedMobileCard, setSelectedMobileCard] = useState<Value | null>(null);
  const [hasShownInstruction, setHasShownInstruction] = useState<boolean>(false);
  const [showStatusDetails, setShowStatusDetails] = useState(true); // New state for status message visibility

  // Hooks
  const {
    sessionId,
    roundNumber,
    targetCoreValues,
    setRoundNumber
  } = useSession();
  const {
    remainingCards,
    categories,
    setCategories,
    setRemainingCards
  } = useGameState();
  const {
    currentRoundCommands,
    addCommand,
    clearCommands
  } = useCommands();
  const {
    isMobile
  } = useMobile();

  // Memoized calculations
  const activeCards = useMemo(() => {
    logEffect('Calculate activeCards', [categories]);
    return Object.entries(categories).filter(([category]) => category !== 'Not Important').reduce((sum, [_, cards]) => sum + (cards?.length || 0), 0);
  }, [categories]);
  const roundState = useRoundState(categories, remainingCards, targetCoreValues);
  const validateRound = useRoundValidation({
    remainingCards,
    targetCoreValues,
    hasMinimumNotImportant: roundState.hasMinimumNotImportant,
    hasEnoughCards: roundState.hasEnoughCards,
    isNearingCompletion: roundState.isNearingCompletion,
    veryImportantCount: roundState.veryImportantCount,
    totalActiveCards: roundState.totalActiveCards,
    categories
  });
  const status = useRoundStatus({
    remainingCards,
    targetCoreValues,
    hasMinimumNotImportant: roundState.hasMinimumNotImportant,
    hasEnoughCards: roundState.hasEnoughCards,
    isNearingCompletion: roundState.isNearingCompletion,
    veryImportantCount: roundState.veryImportantCount,
    totalActiveCards: roundState.totalActiveCards,
    categories
  });

  // Handlers
  const {
    handleMoveCard,
    handleDrop,
    handleMoveBetweenCategories
  } = useRoundHandlers(categories, setCategories, remainingCards, setRemainingCards, roundState.validCategories, roundState.activeCategories, sessionId, roundNumber, currentRoundCommands, addCommand, clearCommands, targetCoreValues, setRoundNumber, setShowResults, setShowStatusDetails);
  const handleMobileDropWithZone = useCallback((card: Value, category: CategoryName) => {
    logStateUpdate('handleMobileDropWithZone', {
      card,
      category
    }, 'RoundUI');
    setActiveDropZone(category);
    handleDrop(card, category);
    setSelectedMobileCard(null);
    setHasShownInstruction(true); // Add this line
    setTimeout(() => setActiveDropZone(null), 1000);
  }, [handleDrop]);
  const handleNextRound = useCallback(async () => {
    try {
      logStateUpdate('handleNextRound', {
        roundNumber
      }, 'RoundUI');
      if (!validateRound()) {
        console.error('Cannot proceed: round validation failed');
        return;
      }
      if (sessionId) {
        await saveRound(sessionId, roundNumber, currentRoundCommands, categories);
      }

      // Check if we have exactly the target number in Very Important
      const hasExactTargetInVeryImportant = (categories['Very Important']?.length || 0) === targetCoreValues;
      if (shouldEndGame) {
        if (sessionId) {
          const finalValues = categories['Very Important'] || [];
          setFinalValuesWithoutReasons(finalValues);
          setShowReasoning(true);
          return;
        }
      }

      // If not ending game, prepare for next round
      clearCommands();
      const nextRound = roundNumber + 1;

      // Get all cards from non-Not Important categories
      const cardsForNextRound = Object.entries(categories).filter(([category]) => category !== 'Not Important').flatMap(([_, cards]) => cards || []);
      if (cardsForNextRound.length < targetCoreValues) {
        console.error('Not enough cards to proceed');
        return;
      }
      const nextCategories = getCategoriesForRound(cardsForNextRound.length, targetCoreValues);
      if (sessionId) {
        await saveRound(sessionId, nextRound, [], nextCategories);
      }
      setRoundNumber(nextRound);
      setCategories(nextCategories);
      setRemainingCards(getRandomValues(cardsForNextRound));
    } catch (error) {
      console.error('Failed to handle next round:', error);
    }
  }, [validateRound, sessionId, roundNumber, currentRoundCommands, categories, shouldEndGame, targetCoreValues, clearCommands, setRoundNumber, setCategories, setRemainingCards]);
  const handleReasoningComplete = useCallback(async (valuesWithReasons: ValueWithReason[]) => {
    logStateUpdate('handleReasoningComplete', {
      valuesWithReasons
    }, 'RoundUI');
    if (sessionId) {
      const session = {
        timestamp: Date.now(),
        targetCoreValues,
        currentRound: roundNumber,
        completed: true
      };
      await updateSession(sessionId, session);
      await saveCompletedSession(sessionId, valuesWithReasons);
    }
    const finalCategories = Object.entries(categories).filter(([category]) => category !== 'Not Important').reduce((acc, [category, cards]) => {
      acc[category] = cards;
      return acc;
    }, {} as Categories);
    setCategories(finalCategories);
    setShowReasoning(false);
    setShowResults(true);
  }, [sessionId, targetCoreValues, roundNumber, categories, setCategories]);

  // Effects
  useEffect(() => {
    // Only end game if we have exactly the target number in Very Important
    const hasExactTargetInVeryImportant = (categories['Very Important']?.length || 0) === targetCoreValues;
    setShouldEndGame(hasExactTargetInVeryImportant && remainingCards.length === 0);
  }, [categories, targetCoreValues, remainingCards.length]);

  // Conditional rendering
  if (showReasoning) {
    return <CoreValueReasoning values={finalValuesWithoutReasons} onComplete={handleReasoningComplete} />;
  }
  if (showResults) {
    return <Results />;
  }
  return <div className={`
        flex flex-col h-full overflow-hidden
        ${isMobile && selectedMobileCard ? 'bg-gray-100' : ''}
        transition-colors duration-200
      `} role="application" aria-label="Core Values Sorting Exercise">
      {/* Game Header - Stays visible but faded when card selected */}
      <div className="flex-shrink-0 relative" // Added relative positioning
    role="banner">
        {/* Selection instruction overlay */}
        {isMobile && selectedMobileCard && !hasShownInstruction && <div className="absolute inset-x-0 top-1/2 -translate-y-1/2 z-10 text-center" aria-live="polite">
            <p className="text-sm text-blue-700 font-medium bg-white/90 py-1 px-2 rounded-full inline-block">
              Tap a category to place this card
            </p>
          </div>}

        <div className={`
        transition-opacity duration-200
        ${isMobile && selectedMobileCard ? 'opacity-30' : 'opacity-100'}
      `}>
          <RoundHeader targetCoreValues={targetCoreValues} roundNumber={roundNumber} remainingCardsCount={remainingCards.length} />
        </div>
      </div>

      {/* Game Actions - Card remains visible when selected */}
      <div className={`
          flex-shrink-0
          ${isMobile && selectedMobileCard ? 'relative z-20' : ''}
        `} role="region" aria-label="Game controls">
        {isMobile ? <div className="px-2 py-1 mb-4">
            <div className="flex items-center justify-center gap-4"> {/* Changed to horizontal layout with center alignment */}
              <div className="flex-1" /> {/* Spacer */}
              <RoundActions remainingCards={remainingCards} canProceedToNextRound={validateRound() && roundState.hasMinimumNotImportant} onNextRound={handleNextRound} onDrop={handleDrop} isEndGame={shouldEndGame} selectedMobileCard={selectedMobileCard} onMobileCardSelect={setSelectedMobileCard} setShowDetails={setShowStatusDetails} />
              <div role="status" aria-live="polite" className={`
          transition-opacity duration-200 flex-1 flex justify-end
          ${selectedMobileCard ? 'opacity-30' : 'opacity-100'}
        `}>
                <StatusMessage status={status()} isNearingCompletion={roundState.isNearingCompletion} hasTooManyImportantCards={roundState.hasTooManyImportantCards} hasNotEnoughImportantCards={roundState.hasNotEnoughImportantCards} hasEnoughCards={roundState.hasEnoughCards} targetCoreValues={targetCoreValues} canProceedToNextRound={validateRound()} remainingCards={remainingCards} showDetails={showStatusDetails} setShowDetails={setShowStatusDetails} />
              </div>
            </div>
          </div> : <div className="container mx-auto">
            <div className="grid grid-cols-3 gap-2 sm:gap-4 p-2 sm:p-4" role="region" aria-label="Game controls and status">
              <div /> {/* Empty first column */}
              <div> {/* Middle column */}
                <RoundActions remainingCards={remainingCards} canProceedToNextRound={validateRound() && roundState.hasMinimumNotImportant} onNextRound={handleNextRound} onDrop={handleDrop} isEndGame={shouldEndGame} />
              </div>
              <div> {/* Third column */}
                <StatusMessage status={status()} isNearingCompletion={roundState.isNearingCompletion} hasTooManyImportantCards={roundState.hasTooManyImportantCards} hasNotEnoughImportantCards={roundState.hasNotEnoughImportantCards} hasEnoughCards={roundState.hasEnoughCards} targetCoreValues={targetCoreValues} canProceedToNextRound={validateRound()} remainingCards={remainingCards} />
              </div>
            </div>
          </div>}
      </div>

      {/* Scrollable Game Content */}
      <div className="flex-1 overflow-auto" role="region" aria-label="Value categories">
        {isMobile ? <div className="h-full flex flex-col pb-16 pt-4"> {/* Added pt-2 for top padding */}
            <MobileCategoryList categories={roundState.visibleCategories} activeDropZone={activeDropZone} onDrop={handleMobileDropWithZone} onMoveWithinCategory={handleMoveCard} onMoveBetweenCategories={handleMoveBetweenCategories} selectedCard={selectedMobileCard} onCardSelect={setSelectedMobileCard} />
          </div> : <div className="w-full">
            <CategoryGrid categories={roundState.visibleCategories} onDrop={handleDrop} onMoveWithinCategory={handleMoveCard} onMoveBetweenCategories={handleMoveBetweenCategories} />
          </div>}
      </div>
    </div>;
});
export default RoundUI;

================
File: src/components/features/Round/RoundUIDebug.tsx
================
// src/components/Round/RoundUIDebug.tsx
'use client'

import { Profiler, ProfilerOnRenderCallback } from 'react';
import RoundUI from './RoundUI';

// Explicitly type the callback using the React type
const onRender: ProfilerOnRenderCallback = function(
  id: string,
  phase: 'mount' | 'update' | 'nested-update',
  actualDuration: number,
  baseDuration: number,
  startTime: number,
  commitTime: number
) {
  if (process.env.NODE_ENV === 'development') {
    console.group(`[Profiler] ${id} - ${phase}`);
    console.log(`Actual duration: ${actualDuration.toFixed(2)}ms`);
    console.log(`Base duration: ${baseDuration.toFixed(2)}ms`);
    console.log(`Start time: ${startTime.toFixed(2)}ms`);
    console.log(`Commit time: ${commitTime.toFixed(2)}ms`);
    console.groupEnd();
  }
};

export default function RoundUIDebug() {
  // Only render profiler in development
  if (process.env.NODE_ENV !== 'development') {
    return <RoundUI />;
  }

  return (
    <div> {/* Hide profiler wrapper from screen readers */}
      <Profiler 
        id="RoundUI" 
        onRender={onRender}
      >
        <RoundUI />
      </Profiler>
    </div>
  );
}

================
File: src/components/features/Round/types.ts
================
// Generated types file

import { Categories, CategoryName, Value } from "@/lib/types";

export interface MobileCardControlsProps {
  canMoveUp: boolean;
  canMoveDown: boolean;
  onMoveUp: () => void;
  onMoveDown: () => void;
  canMoveToPrevCategory: boolean;
  canMoveToNextCategory: boolean;
  onMoveToPrevCategory: () => void;
  onMoveToNextCategory: () => void;
}


export interface MobileCategoryRowProps {
  category: CategoryName;
  cards: Value[];
  availableCategories: CategoryName[];
  isActive: boolean;
  isExpanded: boolean;
  onCategoryTap: (category: CategoryName) => void;
  onCategorySelect: (category: CategoryName) => void;
  showingCardSelection: boolean;
  onMoveWithinCategory?: (fromIndex: number, toIndex: number) => void;
  onMoveBetweenCategories?: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => Promise<void>;
  lastDroppedCategory: CategoryName | null; // Add this line
}

export interface MobileSelectionOverlayProps {
  isVisible: boolean;
}

export interface MobileCardViewProps {
  cards: Value[];
  categorizedCards: Categories;
  onCardPlace: (card: Value, category: CategoryName) => void;
}


export interface MobileCategoryListProps {
  categories: Categories;
  activeDropZone: CategoryName | null;
  onDrop: (card: Value, category: CategoryName) => void;
  onMoveWithinCategory: (category: CategoryName, fromIndex: number, toIndex: number) => Promise<void>;
  onMoveBetweenCategories: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => Promise<void>;
  selectedCard: Value | null;
  onCardSelect: (card: Value | null) => void;
}

export interface StatusMessageProps {
  status: {
    text: string;
    type: 'info' | 'warning' | 'success';
    isEndGame?: boolean;
  };
  isNearingCompletion: boolean;
  hasTooManyImportantCards: boolean;
  hasNotEnoughImportantCards: boolean;
  hasEnoughCards: boolean;
  targetCoreValues: number;
  canProceedToNextRound: boolean;
  remainingCards: any[];
  showDetails?: boolean;
  setShowDetails?: (show: boolean) => void;
}

export interface CategoryGridProps {
  categories: Categories;
  onDrop: (value: Value, category: CategoryName) => Promise<void>;
  onMoveWithinCategory: (category: CategoryName, fromIndex: number, toIndex: number) => Promise<void>;
  onMoveBetweenCategories: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => Promise<void>;
}

export interface RoundActionsProps {
  remainingCards: Value[];
  canProceedToNextRound: boolean;
  onNextRound: () => void;
  onDrop: (card: Value, category: CategoryName) => void;
  isEndGame: boolean;
  setShowDetails?: (show: boolean) => void;
}

export interface RoundHeaderProps {
  targetCoreValues: number;
  roundNumber: number;
  remainingCardsCount: number;
}

export interface RoundUIProps {
  maxCards: number;
  showResults: boolean;
  sessionId?: string;
  roundNumber: number;
  targetCoreValues: number;
  remainingCards: Value[];
  categories: Categories;
  currentRoundCommands: any[]; // Consider creating a specific type for commands
  canProceedToNextRound: boolean;
  isEndGameReady: boolean;
  onMoveCard: (category: CategoryName, fromIndex: number, toIndex: number) => Promise<void>;
  onMoveBetweenCategories: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => Promise<void>;
  onDrop: (value: Value, category: CategoryName) => Promise<void>;
  onNextRound: () => Promise<void>;
}


export interface RoundActionsPropsWithActiveZone extends RoundActionsProps {
  onActiveDropZoneChange?: (category: CategoryName | null) => void;
  selectedMobileCard?: Value | null;
  onMobileCardSelect?: (card: Value | null) => void;
  setShowDetails?: (show: boolean) => void;
}

export interface StatusState {
  remainingCards: Value[];
  targetCoreValues: number;
  categories: Categories;
  hasMinimumNotImportant: boolean;
  hasEnoughCards: boolean;
  isNearingCompletion: boolean;
  veryImportantCount: number;
  totalActiveCards: number;
}

export interface CategoryGridProps {
  categories: Categories;
  onDrop: (value: Value, category: CategoryName) => Promise<void>;
  onMoveWithinCategory: (category: CategoryName, fromIndex: number, toIndex: number) => Promise<void>;
  onMoveBetweenCategories: (value: Value, fromCategory: CategoryName, toCategory: CategoryName) => Promise<void>;
}

export type StatusType = 'info' | 'warning' | 'success';

export interface Status {
  text: string;
  type: StatusType;
  isEndGame?: boolean;
}

================
File: src/components/features/Round/utils/categoryUtils.ts
================
import { CategoryName } from "@/lib/types";
export const getCategories = (activeCardCount: number, targetValue: number): CategoryName[] => {
  const ratio = activeCardCount / targetValue;
  if (ratio <= 1.5) {
    return ['Very Important', 'Not Important'];
  } else if (ratio <= 2) {
    return ['Very Important', 'Quite Important', 'Not Important'];
  } else if (ratio <= 3) {
    return ['Very Important', 'Quite Important', 'Important', 'Not Important'];
  }
  return ['Very Important', 'Quite Important', 'Important', 'Of Some Importance', 'Not Important'];
};

================
File: src/config/config.json
================
{
    "debug": false,
    "maxCards": 35,
    "numCoreValues": 5
}

================
File: src/data/values.json
================
{
    "values": [
        {
            "id" : "1",
            "title": "BEING EXPERT",
            "description": "You like being known as someone with special knowledge or skills."
        },
        {
            "id" : "2",
            "title": "FAST PACE",
            "description": "You enjoy working rapidly at a high pace."
        },
        {
            "id" : "3",
            "title": "MONEY",
            "description": "Earning a large amount of money is important to you."
        },
        {
            "id" : "4",
            "title": "PRESSURE",
            "description": "You like working to deadlines."
        },
        {
            "id" : "5",
            "title": "WORK ALONE",
            "description": "You like to work on your own."
        },
        {
            "id" : "6",
            "title": "COMPETITION",
            "description": "You enjoy competing against other people or groups."
        },
        {
            "id" : "7",
            "title": "PRECISE WORK",
            "description": "You like working on things which involve great care and concentration."
        },
        {
            "id" : "8",
            "title": "ARTISTIC",
            "description": "You enjoy making music, making designs, writing poetry, making models etc."
        },
        {
            "id" : "9",
            "title": "PHYSICAL CHALLENGE",
            "description": "You enjoy doing something that is physically demanding."
        },
        {
            "id" : "10",
            "title": "A WELL-KNOWN ORGANISATION",
            "description": "You like being part of a well-known organisation."
        },
        {
            "id" : "11",
            "title": "STATUS",
            "description": "You enjoy being in a position which leads other people to respect you."
        },
        {
            "id" : "12",
            "title": "VARIETY",
            "description": "You enjoy having lots of different things to do."
        },
        {
            "id" : "13",
            "title": "ROUTINE",
            "description": "You like having a routine which is fairly predictable."
        },
        {
            "id" : "14",
            "title": "CONTACT WITH PEOPLE",
            "description": "You enjoy having a lot of contact with people."
        },
        {
            "id" : "15",
            "title": "TIME FREEDOM",
            "description": "You prefer to decide how to use your own time, rather than having a rigid daily routine."
        },
        {
            "id" : "16",
            "title": "COMMUNICATION",
            "description": "You enjoy being able to express ideas or feelings to other people."
        },
        {
            "id" : "17",
            "title": "PERSUADING PEOPLE",
            "description": "You enjoy persuading people to buy something or change their minds about something."
        },
        {
            "id" : "18",
            "title": "PROMOTION",
            "description": "You like to work where there is a good chance of promotion."
        },
        {
            "id" : "19",
            "title": "SECURITY",
            "description": "It is important to know your work will always be there for you."
        },
        {
            "id" : "20",
            "title": "FRIENDSHIP",
            "description": "You would or do like close friendships with people at work."
        },
        {
            "id" : "21",
            "title": "SUPERVISION",
            "description": "You enjoy being responsible for work done by others."
        },
        {
            "id" : "22",
            "title": "RISK",
            "description": "You like to take risks."
        },
        {
            "id" : "23",
            "title": "RECOGNITION",
            "description": "You do like people to appreciate you for the work you do."
        },
        {
            "id" : "24",
            "title": "HELP SOCIETY",
            "description": "You like to think that your work is producing something worthwhile for society."
        },
        {
            "id" : "25",
            "title": "PLACE OF WORK",
            "description": "It is important that you work in the right part of the country for you."
        },
        {
            "id" : "26",
            "title": "EXCITEMENT",
            "description": "It is important for you to have a lot of excitement in your work."
        },
        {
            "id" : "27",
            "title": "MAKING DECISIONS",
            "description": "It is important to you to have to make decisions about how things should be done, who should do it and when it should be done."
        },
        {
            "id" : "28",
            "title": "CHALLENGE",
            "description": "You enjoy being 'stretched' and given new problems to work on."
        },
        {
            "id" : "29",
            "title": "HELPING OTHERS",
            "description": "It is important to you to help other people either individually or in groups, as part of your work."
        },
        {
            "id" : "30",
            "title": "COMMUNITY",
            "description": "You like to live in a place where you can get involved in the community."
        },
        {
            "id" : "31",
            "title": "INDEPENDENCE",
            "description": "You like being able to work in the way you want, without others telling you what to do."
        },
        {
            "id" : "32",
            "title": "WORK WITH OTHERS",
            "description": "You like to work in a team alongside others."
        },
        {
            "id" : "33",
            "title": "PEACE",
            "description": "You prefer to have few pressures and uncomfortable demands."
        },
        {
            "id" : "34",
            "title": "LEARNING",
            "description": "It is important for you to learn new things."
        },
        {
            "id" : "35",
            "title": "CREATIVITY",
            "description": "Thinking up new ideas and ways of doing things is important to you."
        }
    ]
  }

================
File: src/hooks/useSessionReconstruction.ts
================
import { useState, useEffect } from 'react';
import { Categories, Command, Round, Value, CategoryName, DropCommandPayload, MoveCommandPayload } from "@/lib/types";
import { getRoundsBySession } from "@/lib/db/indexedDB";
import valuesData from '@/data/values.json';
import {ReconstructedState} from '@/lib/types'

export function useSessionReconstruction(sessionId: string | null) {
  const [reconstructedState, setReconstructedState] = useState<ReconstructedState | null>(null);
  useEffect(() => {
    if (!sessionId) return;
    const reconstructState = async () => {
      const rounds = await getRoundsBySession(sessionId);

      // Initialize categories
      let categories: Categories = {
        'Very Important': [],
        'Quite Important': [],
        'Important': [],
        'Of Some Importance': [],
        'Not Important': []
      };

      // Create a map of all possible values from values.json
      const allValues = new Map<string, Value>(valuesData.values.map(value => [value.id, value]));

      // Second pass: reconstruct categories
      for (const round of rounds) {
        for (const command of round.commands) {
          if (command.type === 'DROP') {
            const dropPayload = command.payload as DropCommandPayload;
            const value = allValues.get(dropPayload.cardId);
            if (value && dropPayload.category in categories) {
              categories[dropPayload.category] = [...(categories[dropPayload.category] ?? []), value];
            }
          } else if (command.type === 'MOVE') {
            const movePayload = command.payload as MoveCommandPayload;
            const value = allValues.get(movePayload.cardId);
            if (value && movePayload.fromCategory in categories && movePayload.toCategory in categories) {
              // Remove from source
              const sourceCategory = categories[movePayload.fromCategory] ?? [];
              categories[movePayload.fromCategory] = sourceCategory.filter(v => v.id !== movePayload.cardId);

              // Add to target
              const targetCategory = categories[movePayload.toCategory] ?? [];
              categories[movePayload.toCategory] = [...targetCategory, value];
            }
          }
        }
      }

      // Calculate remaining cards
      const usedCardIds = new Set(Object.values(categories).flatMap(cards => cards?.map(card => card.id) ?? []));
      const remainingCards = valuesData.values.filter(value => !usedCardIds.has(value.id));
      setReconstructedState({
        categories,
        currentRound: rounds.length,
        remainingCards
      });
    };
    reconstructState();
  }, [sessionId]);
  return reconstructedState;
}

================
File: src/lib/contexts/MobileContext.tsx
================
'use client'

import { createContext, useContext, useState, useEffect, ReactNode } from 'react';

interface MobileContextType {
  isMobile: boolean;
}

const MobileContext = createContext<MobileContextType | undefined>(undefined);

export function MobileProvider({ children }: { children: ReactNode }) {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    // Initial check
    checkMobile();
    
    // Add event listener
    window.addEventListener('resize', checkMobile);
    
    // Cleanup
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  return (
    <MobileContext.Provider value={{ isMobile }}>
      {children}
    </MobileContext.Provider>
  );
}

export function useMobile() {
  const context = useContext(MobileContext);
  if (context === undefined) {
    throw new Error('useMobile must be used within a MobileProvider');
  }
  return context;
}

================
File: src/lib/db/indexedDB.ts
================
'use client';

import { getEnvBoolean } from '@/lib/utils/config';
import { generateSessionName } from '@/components/features/Game/utils';
import { openDB, IDBPDatabase } from 'idb';
import { Session } from "@/lib/types/Session";
import { Round } from "@/lib/types/Round";
import { Command } from "@/lib/types/Command";
import { Value, CompletedSession, Categories } from "@/lib/types";
const isBrowser = typeof window !== 'undefined';
const dbName = 'coreValuesData';
const dbVersion = 3;
const storeNames = {
  sessions: 'sessions',
  rounds: 'rounds',
  completedSessions: 'completedSessions'
};
const debug = getEnvBoolean('debug', false);

// Database initialization
export async function initDB(): Promise<IDBPDatabase> {
  if (debug) console.log('🔵 Initializing IndexedDB');
  try {
    const db = await openDB(dbName, dbVersion, {
      upgrade(db, oldVersion, newVersion) {
        if (debug) console.log('🆙 Upgrading IndexedDB schema');

        // Create stores
        if (!db.objectStoreNames.contains(storeNames.sessions)) {
          db.createObjectStore(storeNames.sessions, {
            keyPath: 'id'
          });
        }

        // Handle rounds store
        if (!db.objectStoreNames.contains(storeNames.rounds)) {
          // Create new store with index
          const store = db.createObjectStore(storeNames.rounds, {
            keyPath: ['sessionId', 'roundNumber']
          });
          try {
            store.createIndex('sessionId', 'sessionId');
          } catch (e) {
            console.warn('Failed to create index:', e);
          }
        }
        if (!db.objectStoreNames.contains(storeNames.completedSessions)) {
          db.createObjectStore(storeNames.completedSessions, {
            keyPath: 'sessionId'
          }); // Single string, not array
        }
      }
    });
    if (debug) console.log('✅ IndexedDB initialized successfully');
    return db;
  } catch (error) {
    console.error('❌ Error initializing IndexedDB:', error);
    throw error;
  }
}

// Session operations
export async function addSession(session: Omit<Session, 'id'>): Promise<string> {
  if (debug) console.log('💾 Saving session:', session);
  try {
    const db = await initDB();
    const sessionId = await generateSessionName(db);
    await db.put(storeNames.sessions, {
      ...session,
      id: sessionId
    });
    if (debug) console.log('✅ Session saved successfully');
    return sessionId;
  } catch (error) {
    console.error('❌ Error saving session:', error);
    throw error;
  }
}
export async function getSessions(): Promise<Session[]> {
  if (debug) console.log('🔍 Fetching all sessions');
  try {
    const db = await initDB();
    const sessions = await db.getAll(storeNames.sessions);
    if (debug) console.log('✅ Sessions fetched successfully:', sessions);
    return sessions;
  } catch (error) {
    console.error('❌ Error fetching sessions:', error);
    throw error;
  }
}
export async function updateSession(sessionId: string, updates: Partial<Session>) {
  if (debug) console.log('🔄 Updating session:', {
    sessionId,
    updates
  });
  try {
    const db = await initDB();
    const tx = db.transaction(storeNames.sessions, 'readwrite');
    const store = tx.objectStore(storeNames.sessions);
    const session = await store.get(sessionId);
    if (session) {
      await store.put({
        ...session,
        ...updates
      });
      if (debug) console.log('✅ Session updated successfully');
    }
    await tx.done;
  } catch (error) {
    console.error('❌ Error updating session:', error);
    throw error;
  }
}

// Round operations
export async function saveRound(sessionId: string, roundNumber: number, commands: Command[], availableCategories: Categories // Add this parameter
): Promise<void> {
  if (debug) console.log('💾 Saving round:', {
    sessionId,
    roundNumber,
    commands
  });
  try {
    if (!sessionId) return;
    const db = await initDB();
    const existingRound = await db.get(storeNames.rounds, [sessionId, roundNumber]);
    const round: Round = {
      sessionId,
      roundNumber,
      commands,
      availableCategories,
      timestamp: Date.now()
    };
    if (existingRound) {
      if (debug) console.log('🔄 Updating existing round');
      await db.put(storeNames.rounds, {
        ...existingRound,
        commands: round.commands,
        availableCategories: round.availableCategories,
        timestamp: round.timestamp
      });
    } else {
      if (debug) console.log('➕ Creating new round');
      await db.add(storeNames.rounds, round);
    }
    if (debug) console.log('✅ Round saved successfully');
  } catch (error) {
    console.error('❌ Error saving round:', error);
    throw error;
  }
}
export async function getRound(sessionId: string, roundNumber: number): Promise<Round | undefined> {
  if (debug) console.log('🔍 Fetching round:', {
    sessionId,
    roundNumber
  });
  try {
    const db = await initDB();
    const round = await db.get(storeNames.rounds, [sessionId, roundNumber]);
    if (debug) console.log('✅ Round fetched successfully:', round);
    return round;
  } catch (error) {
    console.error('❌ Error fetching round:', error);
    throw error;
  }
}
export async function getRoundsBySession(sessionId: string): Promise<Round[]> {
  if (debug) console.log('🔍 Fetching all rounds for session:', sessionId);
  try {
    const db = await initDB();
    const rounds = await db.getAllFromIndex(storeNames.rounds, 'sessionId', sessionId);
    if (debug) console.log('✅ Rounds fetched successfully:', rounds);
    return rounds;
  } catch (error) {
    console.error('❌ Error fetching rounds:', error);
    throw error;
  }
}

// Completed sessions operations
export async function saveCompletedSession(sessionId: string, finalValues: Value[]) {
  if (debug) console.log('💾 Saving completed session:', {
    sessionId,
    valuesCount: finalValues.length
  });
  try {
    const db = await initDB();
    await db.put(storeNames.completedSessions, {
      sessionId,
      // This needs to be included since it's the keyPath
      finalValues,
      timestamp: Date.now()
    }); // No need for second argument since sessionId is in the object as keyPath
    if (debug) console.log('✅ Completed session saved successfully');
  } catch (error) {
    console.error('❌ Error saving completed session:', error);
    throw error;
  }
}
export async function getCompletedSession(sessionId: string): Promise<CompletedSession | undefined> {
  if (debug) console.log('🔍 Fetching completed session:', sessionId);
  try {
    const db = await initDB();
    const completedSession = await db.get(storeNames.completedSessions, sessionId);
    if (debug) console.log('✅ Completed session fetched successfully:', completedSession);
    return completedSession;
  } catch (error) {
    console.error('❌ Error fetching completed session:', error);
    throw error;
  }
}

================
File: src/lib/hooks/useAnimation.ts
================
import { useEffect, useState } from 'react';
import { useMotionValue, useSpring, MotionValue } from 'framer-motion';
import { Position,AnimationConfig } from "@/lib/types";

export const useAnimation = (initialPosition: Position, config: AnimationConfig = {}) => {
  const x = useMotionValue(initialPosition.x);
  const y = useMotionValue(initialPosition.y);
  const springX = useSpring(x, {
    stiffness: config.stiffness ?? 300,
    damping: config.damping ?? 30,
    mass: config.mass ?? 1
  });
  const springY = useSpring(y, {
    stiffness: config.stiffness ?? 300,
    damping: config.damping ?? 30,
    mass: config.mass ?? 1
  });
  return {
    x: springX,
    y: springY
  };
};

================
File: src/lib/hooks/usePWA.ts
================
'use client';

import { useState, useEffect } from 'react';
import { PWAStatus } from "@/lib/types";

export function usePWA() {
  const [status, setStatus] = useState<PWAStatus>({
    needsUpdate: false,
    isOffline: false // Default to false, will update in useEffect
  });

  useEffect(() => {
    // Update initial offline status
    setStatus(prev => ({
      ...prev,
      isOffline: !window.navigator.onLine
    }));

    const handleStatusChange = () => {
      setStatus(prevStatus => ({
        ...prevStatus,
        isOffline: !window.navigator.onLine
      }));
    };

    window.addEventListener('online', handleStatusChange);
    window.addEventListener('offline', handleStatusChange);

    return () => {
      window.removeEventListener('online', handleStatusChange);
      window.removeEventListener('offline', handleStatusChange);
    };
  }, []);

  useEffect(() => {
    if (typeof window !== 'undefined' && 'serviceWorker' in window.navigator) {
      window.navigator.serviceWorker.ready.then(registration => {
        registration.addEventListener('controllerchange', () => {
          setStatus(prevStatus => ({
            ...prevStatus,
            needsUpdate: true
          }));
        });
      });
    }
  }, []);

  const updateServiceWorker = async () => {
    if (typeof window !== 'undefined' && 'serviceWorker' in window.navigator) {
      const registration = await window.navigator.serviceWorker.ready;
      await registration.update();
      setStatus(prevStatus => ({
        ...prevStatus,
        needsUpdate: false
      }));
      window.location.reload();
    }
  };

  return {
    ...status,
    updateServiceWorker
  };
}

================
File: src/lib/store/store.ts
================
'use client';

import { createWithEqualityFn } from 'zustand/traditional';
import { devtools } from 'zustand/middleware';
import { emptyCategories } from "@/components/features/Categories/constants/categories";
import { saveRound } from "@/lib/db/indexedDB";
import { StoreState } from "@/lib/types";
import { shallow } from 'zustand/shallow';

export const useStore = createWithEqualityFn<StoreState>()(devtools((set, get) => ({
  // Initial state
  sessionId: '',
  roundNumber: 1,
  targetCoreValues: 10,
  remainingCards: [],
  categories: emptyCategories,
  isGameStarted: false,
  showInstructions: false,
  commands: [],
  currentRound: null,
  currentRoundCommands: [],
  // Session methods
  setSession: session => set({
    sessionId: session.sessionId,
    targetCoreValues: session.targetCoreValues,
    roundNumber: session.roundNumber
  }),
  setSessionId: id => set({
    sessionId: id
  }),
  setRoundNumber: round => set({
    roundNumber: round
  }),
  setTargetCoreValues: count => set({
    targetCoreValues: count
  }),
  clearSession: () => set({
    sessionId: '',
    targetCoreValues: 10,
    roundNumber: 1
  }),
  // Game methods
  setRemainingCards: cards => set({
    remainingCards: cards
  }),
  setCategories: categories => set({
    categories
  }),
  setGameStarted: started => set({
    isGameStarted: started
  }),
  setShowInstructions: show => set({
    showInstructions: show
  }),
  resetGame: () => set({
    roundNumber: 1,
    remainingCards: [],
    categories: emptyCategories,
    isGameStarted: false,
    showInstructions: false,
    commands: [],
    currentRound: null,
    currentRoundCommands: []
  }),
  // Command methods
  addCommand: async command => {
    set(state => ({
      commands: [...state.commands, command],
      currentRoundCommands: [...state.currentRoundCommands, command]
    }));
    const {
      currentRound,
      commands
    } = get();
    if (currentRound) {
      await saveRound(currentRound.sessionId, currentRound.roundNumber, commands, currentRound.availableCategories);
    }
  },
  clearCommands: () => set({
    commands: [],
    currentRoundCommands: []
  })
}), {
  name: 'Game Store'
}), shallow);

================
File: src/lib/types/Animation.ts
================
// src/lib/types/Animation.ts
import { MotionValue } from 'framer-motion';
import { Position } from './Position';

export interface AnimationConfig {
  stiffness?: number;
  damping?: number;
  mass?: number;
  duration?: number;
}

================
File: src/lib/types/BaseCommand.ts
================
import { Position } from './Position';

export interface BaseCommand {
  sourcePosition?: Position;
  targetPosition?: Position;
}

================
File: src/lib/types/Categories.ts
================
import { Value } from "./Value";
import { CategoryName } from "./CategoryName";

// In src/types/Categories.ts
export interface Categories {
  'Very Important': Value[];
  'Not Important': Value[];
  'Quite Important'?: Value[];
  'Important'?: Value[];
  'Of Some Importance'?: Value[];
  [key: string]: Value[] | undefined;  // Add index signature
}
// These types can be used for type checking in specific rounds
export type Round1And2Categories = Required<Categories>;

export type Round3Categories = Required<Omit<Categories, 'Of Some Importance'>>;

export type Round4Categories = Pick<Categories, 'Very Important' | 'Not Important'>;

================
File: src/lib/types/Category.ts
================
export enum Category {
    VERY_IMPORTANT = "Very Important",
    QUITE_IMPORTANT = "Quite Important",
    IMPORTANT = "Important",
    OF_SOME_IMPORTANCE = "Of Some Importance",
    NOT_IMPORTANT = "Not Important"
}

================
File: src/lib/types/CategoryName.ts
================
export type CategoryName = 
  | "Very Important"
  | "Quite Important"
  | "Important"
  | "Of Some Importance"
  | "Not Important";

================
File: src/lib/types/Command.ts
================
import { Position } from './Position';

export interface Command {
    type: string;
    payload: unknown;
    timestamp: number;
    sourcePosition?: Position;
    targetPosition?: Position;
    setPositions(source?: Position, target?: Position): Command;
}

================
File: src/lib/types/CompletedSession.ts
================
import { Value } from './Value';

export interface ValueWithReason extends Value {
    reason?: string;
  }

export interface CompletedSession {
    sessionId: string;
    finalValues: ValueWithReason[];
    timestamp: number;
}

================
File: src/lib/types/Context.ts
================
// src/lib/types/Context.ts
export interface MobileContextType {
  isMobile: boolean;
}

================
File: src/lib/types/DropCommandPayload.ts
================
import { CategoryName } from "./CategoryName";
export interface DropCommandPayload {
    cardId: string;
    cardTitle: string; // Add this
    category: CategoryName;
}

================
File: src/lib/types/index.ts
================
// Animation related exports
export type { AnimationConfig } from './Animation';
export type { Position } from './Position';

// Context related exports
export type { MobileContextType } from './Context';

// PWA related exports
export type { PWAStatus } from './PWA';

// Session related exports
export type { ReconstructedState } from './Session';

// Store related exports
export type { StoreState } from './Store';

// Existing exports (keeping these as they are)
export type { CompletedSession, ValueWithReason } from './CompletedSession';
export type { Categories } from './Categories';
export type { Category } from './Category';
export type { CategoryName } from './CategoryName';
export type { Command } from './Command';
export type { DropCommandPayload } from './DropCommandPayload';
export type { MoveCommandPayload } from './MoveCommandPayload';
export type { Round } from './Round';
export type { Session } from './Session';
export type { SessionReconstruction } from './SessionReconstruction';
export type { Value } from './Value';

================
File: src/lib/types/MoveCommandPayload.ts
================
import { CategoryName } from "./CategoryName";

export interface MoveCommandPayload {
    cardId: string;
    cardTitle: string; // Add this
    fromCategory: CategoryName;
    toCategory: CategoryName;
    fromIndex?: number;
    toIndex?: number;
}

================
File: src/lib/types/Position.ts
================
export interface Position {
  x: number;
  y: number;
}

================
File: src/lib/types/PWA.ts
================
// src/lib/types/PWA.ts
export interface PWAStatus {
  needsUpdate: boolean;
  isOffline: boolean;
}

================
File: src/lib/types/Round.ts
================
import { Categories } from "./Categories";
import { Command } from "./Command";


export interface Round {
    sessionId: string;
    roundNumber: number;
    commands: Command[];
    availableCategories: Categories; // Add this to store the calculated categories for the round
    timestamp: number;
}

================
File: src/lib/types/serviceWorker.d.ts
================
// Extend the existing Window interface
interface Window {
  workbox: any;
}

// Define ServiceWorkerGlobalScope
interface ServiceWorkerGlobalScope extends WorkerGlobalScope {
  __WB_MANIFEST: any[];
  skipWaiting(): Promise<void>;
  clients: Clients;
}

================
File: src/lib/types/Session.ts
================
// src/types/Session.ts
import { Categories } from './Categories';
import { Value } from './Value';

export interface Session {
  id: string;
  timestamp: number;
  targetCoreValues: number;
  currentRound: number;
  completed: boolean;
}

export interface ReconstructedState {
  categories: Categories;
  currentRound: number;
  remainingCards: Value[];
}

================
File: src/lib/types/SessionReconstruction.ts
================
import { Categories, Value } from "@/lib/types";
export interface SessionReconstruction {
  categories: Categories;
  currentRound: number;
  remainingCards: Value[];
}

================
File: src/lib/types/Store.ts
================
// src/lib/types/Store.ts
import { Categories, Value, Command, Round } from './index';

export interface StoreState {
  sessionId: string;
  roundNumber: number;
  targetCoreValues: number;
  remainingCards: Value[];
  categories: Categories;
  isGameStarted: boolean;
  showInstructions: boolean;
  commands: Command[];
  currentRound: Round | null;
  currentRoundCommands: Command[];
  
  setSession: (session: {
    sessionId: string;
    targetCoreValues: number;
    roundNumber: number;
  }) => void;
  setSessionId: (id: string) => void;
  setRoundNumber: (round: number) => void;
  setTargetCoreValues: (count: number) => void;
  clearSession: () => void;
  setRemainingCards: (cards: Value[]) => void;
  setCategories: (categories: Categories) => void;
  setGameStarted: (started: boolean) => void;
  setShowInstructions: (show: boolean) => void;
  resetGame: () => void;
  addCommand: (command: Command) => Promise<void>;
  clearCommands: () => void;
}

================
File: src/lib/types/Value.ts
================
import { Category } from "./Category";


export type Value = {
    id: string;
    title: string;
    description: string;
    category?: Category;
};

================
File: src/lib/utils/animation/index.ts
================
export * from './transitions';
export * from './variants';

================
File: src/lib/utils/animation/transitions.ts
================
import { Transition } from "framer-motion";

export const springTransition: Transition = {
  type: "spring",
  stiffness: 300,
  damping: 30
};

export const easeTransition: Transition = {
  type: "tween",
  ease: "easeInOut",
  duration: 0.3
};

export const cardTransition: Transition = {
  type: "spring",
  stiffness: 500,
  damping: 35,
  mass: 1
};

================
File: src/lib/utils/animation/variants.ts
================
import { Variants } from "framer-motion";

export const cardVariants: Variants = {
  initial: { 
    scale: 1.0, 
    opacity: 0 
  },
  animate: { 
    scale: 1, 
    opacity: 1 
  },
  exit: { 
    scale: 1.0, 
    opacity: 0 
  },
  hover: { 
    scale: 1.00,
    transition: {
      duration: 0.2
    }
  }
};

export const categoryVariants: Variants = {
  initial: { 
    y: 20, 
    opacity: 0 
  },
  animate: { 
    y: 0, 
    opacity: 1 
  },
  exit: { 
    y: -20, 
    opacity: 0 
  }
};

================
File: src/lib/utils/cache/index.ts
================
// src/utils/cache.ts
export const forceReload = () => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(function(registrations) {
        for(let registration of registrations) {
          registration.unregister();
        }
        window.location.reload();
      });
    } else {
      window.location.reload();
    }
  };

================
File: src/lib/utils/config/envUtils.ts
================
export function getEnvNumber(key: string, defaultValue: number): number {
  // In development, return default values
  if (process.env.NODE_ENV === 'development') {
    if (key === 'maxCards') {
      return 10;
    }
    if (key === 'numCoreValues') {
      return 5;
    }
    return defaultValue;
  }

  // In production, use environment variables
  const value = process.env[key];
  if (value === undefined) {
    return defaultValue;
  }
  
  const numberValue = Number(value);
  return isNaN(numberValue) ? defaultValue : numberValue;
}

export function getEnvBoolean(key: string, defaultValue: boolean): boolean {
  // In development, return default values
  if (process.env.NODE_ENV === 'development') {
    return defaultValue;
  }

  // In production, use environment variables
  const value = process.env[key];
  if (value === undefined) {
    return defaultValue;
  }
  
  return value.toLowerCase() === 'true';
}

================
File: src/lib/utils/config/gameConfig.ts
================
import { getEnvNumber } from './envUtils';

export const getGameConfig = () => ({
  maxCards: getEnvNumber('maxCards', 35),
  defaultCoreValues: getEnvNumber('numCoreValues', 5),
  minNotImportant: 1,  // Minimum cards that must be in Not Important
  ratioThresholds: {
    final: 1.5,     // Ratio for final round (2 categories)
    reduced: 2,     // Ratio for reduced categories (3 categories)
    standard: 3,    // Ratio for standard categories (4 categories)
    // Above standard ratio shows all categories
  }
});

export const validateGameConstraints = (
  activeCards: number,
  targetCoreValues: number,
  notImportantCount: number
) => {
  const config = getGameConfig();
  
  return {
    hasMinimumNotImportant: notImportantCount >= config.minNotImportant,
    hasEnoughCards: activeCards >= targetCoreValues,
    isTooManyCards: activeCards > config.maxCards
  };
};

================
File: src/lib/utils/config/index.ts
================
// Export all environment utilities
export * from './envUtils';

// Export all game configuration utilities
export * from './gameConfig';

================
File: src/lib/utils/debug/index.ts
================
const DEBUG = process.env.NODE_ENV === 'development';

export const logRender = (componentName: string, props?: any) => {
  if (DEBUG) {
    console.log(`[Render] ${componentName}`, props ? { props } : '');
  }
};

export const logStateUpdate = (name: string, value: any, source: string) => {
  if (DEBUG) {
    console.group(`[State Update] ${name}`);
    console.log('Value:', value);
    console.log('Source:', source);
    console.trace('Stack trace');
    console.groupEnd();
  }
};

export const logEffect = (effectName: string, dependencies?: any[]) => {
  if (DEBUG) {
    console.log(`[Effect] ${effectName}`, dependencies ? { dependencies } : '');
  }
};

================
File: src/lib/utils/dom/index.ts
================
import { Position } from "@/lib/types";
export const getElementCenter = (element: HTMLElement): Position => {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
};
export const getCardPosition = (cardId: string): Position | undefined => {
  const element = document.getElementById(`card-${cardId}`);
  return element ? getElementCenter(element) : undefined;
};
export const getCategoryPosition = (categoryName: string): Position | undefined => {
  const element = document.getElementById(`category-${categoryName}`);
  return element ? getElementCenter(element) : undefined;
};

================
File: src/lib/utils/email/emailUtils.ts
================
import { Value, ValueWithReason } from "@/lib/types";
export function generateEmailContent(values: ValueWithReason[]): string {
  const emailSubject = 'My Core Values Results';
  const htmlContent = `
    <html>
      <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <h1 style="color: #2563eb;">My Core Values</h1>
        <p>Here are my selected core values and their significance:</p>
        ${values.map(value => `
          <div style="margin-bottom: 20px; padding: 15px; background-color: #fef9c3; border-radius: 8px;">
            <h2 style="margin: 0; color: #1f2937; font-size: 18px;">${value.title}</h2>
            <p style="margin: 8px 0; color: #4b5563;">${value.description}</p>
            ${value.reason ? `
              <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #d1d5db;">
                <p style="margin: 0; font-style: italic; color: #4b5563;">
                  <strong>Why it's meaningful:</strong> ${value.reason}
                </p>
              </div>
            ` : ''}
          </div>
        `).join('')}
      </body>
    </html>
  `;

  // Remove any newlines and extra spaces to make the mailto link cleaner
  const cleanHtmlContent = htmlContent.replace(/\s+/g, ' ').trim();

  // Create the mailto link
  const mailtoLink = `mailto:?subject=${encodeURIComponent(emailSubject)}&body=${encodeURIComponent(cleanHtmlContent)}`;
  return mailtoLink;
}
export function shareViaEmail(values: Value[]) {
  const mailtoLink = generateEmailContent(values);
  window.location.href = mailtoLink;
}

================
File: src/lib/utils/index.ts
================
// Animation utilities
export * from './animation';

// Cache utilities
export * from './cache';

// Config utilities
export * from './config';

// DOM utilities
export * from './dom';

// Email utilities
export * from './email/emailUtils';

// Storage utilities
export * from './storage/cacheUtils';
export * from './storage/storeUtils';
export * from './storage';

export * from './debug';

// Note: Removed the default exports since the utilities aren't exported as defaults
// Instead, they're already being exported through their respective index files

================
File: src/lib/utils/storage/cacheUtils.ts
================
export const cacheUtils = {
  async getCachedData<T>(key: string): Promise<T | null> {
    try {
      const cache = await caches.open('core-values-dynamic-v1');
      const response = await cache.match(`/api/${key}`);
      if (response) {
        return response.json();
      }
      return null;
    } catch (error) {
      console.error('Error getting cached data:', error);
      return null;
    }
  },

  async setCachedData<T>(key: string, data: T): Promise<void> {
    try {
      const cache = await caches.open('core-values-dynamic-v1');
      const response = new Response(JSON.stringify(data));
      await cache.put(`/api/${key}`, response);
    } catch (error) {
      console.error('Error setting cached data:', error);
    }
  },

  async clearCache(): Promise<void> {
    try {
      const cache = await caches.open('core-values-dynamic-v1');
      await cache.keys().then(keys => {
        keys.forEach(key => {
          cache.delete(key);
        });
      });
    } catch (error) {
      console.error('Error clearing cache:', error);
    }
  }
};

================
File: src/lib/utils/storage/index.ts
================
import { cacheUtils } from './cacheUtils';
import { initializeGameState, clearGameState } from './storeUtils';

export {
    cacheUtils,
    initializeGameState,
    clearGameState
};

================
File: src/lib/utils/storage/storeUtils.ts
================
import { useStore } from "@/lib/store/store";
import { Value, Categories } from "@/lib/types";
import { emptyCategories } from "@/components/features/Categories/constants/categories";
export const initializeGameState = (sessionId: string, targetCoreValues: number, initialCards: Value[], initialCategories: Categories = emptyCategories) => {
  const store = useStore.getState();

  // Session state
  store.setSession({
    sessionId,
    targetCoreValues,
    roundNumber: 1 // updated from currentRound
  });

  // Game state
  store.setRemainingCards(initialCards);
  store.setCategories(initialCategories);
  store.setGameStarted(true);
  store.setShowInstructions(true);

  // Commands state
  store.clearCommands();
};
export const clearGameState = () => {
  const store = useStore.getState();

  // Clear all state
  store.setSession({
    sessionId: '',
    targetCoreValues: 10,
    roundNumber: 1 // updated from currentRound
  });
  store.resetGame();
  store.clearCommands();
};

================
File: src/lib/worker/index.ts
================
/// <reference lib="webworker" />
import { cacheNames, clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { NetworkFirst, StaleWhileRevalidate, CacheFirst } from 'workbox-strategies'
import { registerRoute } from 'workbox-routing'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'

declare const self: ServiceWorkerGlobalScope

// Use the injected cache version from next.config.js
const CACHE_VERSION = process.env.CACHE_VERSION || Date.now().toString()

// Customize cache names with version
const customCacheNames = {
  runtime: `runtime-${CACHE_VERSION}`,
  static: `static-${CACHE_VERSION}`,
  image: `images-${CACHE_VERSION}`,
  api: `api-${CACHE_VERSION}`
}

clientsClaim()

// Cache static assets
registerRoute(
  ({ request }) => request.destination === 'style' || 
                   request.destination === 'script' || 
                   request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: customCacheNames.static,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      })
    ]
  })
)

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: customCacheNames.image,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
)

// Cache API requests
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: customCacheNames.api,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60 // 5 minutes
      })
    ]
  })
)

// Clean up old caches
self.addEventListener('activate', (event: ExtendableEvent) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          // Delete old versioned caches
          if (!Object.values(customCacheNames).includes(cacheName)) {
            return caches.delete(cacheName)
          }
          return Promise.resolve()
        })
      )
    })
  )
})

// Ensure TypeScript treats this as a module
export {}

================
File: src/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 248, 250, 252;
}

/* Background with a diagonal gradient */
body {
  background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
  background-size: cover;
  background-repeat: no-repeat;
  background-attachment: fixed;
  min-height: 100vh;
}


/* Add a semi-transparent overlay to improve text readability if needed */
.content-overlay {
  background-color: rgba(255, 255, 255, 0.9);
  min-height: 100vh;
}

.card {
  @apply transition-all duration-200 ease-in-out;
}

.card:hover {
  @apply shadow-md;
}

.category-column {
  @apply transition-colors duration-200 ease-in-out;
}

@media print {
  /* Remove any background images/effects from post-it notes */
  [class*="postit-"] {
    background-image: none !important;
    transform: none !important;
    box-shadow: none !important;
  }

  /* Ensure text is black for printing */
  * {
    color: black !important;
  }

  /* Hide unnecessary elements when printing */
  .print:hidden {
    display: none !important;
  }
}

================
File: tailwind.config.ts
================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      // Add any custom theme extensions here
      colors: {
        // Custom colors can be added here
      },
      fontFamily: {
        // Custom fonts can be added here
        'handwritten': ['var(--font-kalam)']
      },
      rotate: {
        '1': '1deg',
      },
    },
  },
  variants: {
    extend: {
      transform: ['hover', 'print'],
      translate: ['hover', 'print'],
      backgroundColor: ['print'],
      borderWidth: ['print'],
      borderColor: ['print'],
      textColor: ['print'],
    },
  },
  plugins: [],
  // Enable JIT mode
  darkMode: 'class', // or 'media' if you prefer system settings
  // If you need to prefix your classes (usually not needed for Next.js)
  prefix: '',
  // Important can be set to true if needed
  important: false,
}

export default config

================
File: tests/components/Card.test.tsx
================
// in Card.test.tsx
import { createMockValue, resetMockIdCounter } from '../utils/mockData';

describe('Card Component', () => {
  beforeEach(() => {
    resetMockIdCounter(); // Optional: reset ID counter before each test
  });

  it('renders card content correctly', () => {
    const testValue = createMockValue({
      title: 'Test Title',
      description: 'Test Description'
    });
    // testValue.id will be 1
    // ... rest of the test
  });

  it('other test case', () => {
    const testValue = createMockValue({
      title: 'Another Title',
      description: 'Another Description'
    });
    // testValue.id will be 2
    // ... rest of the test
  });

  it('can override id if needed', () => {
    const testValue = createMockValue({
      id: 35,
      title: 'Specific ID Test',
      description: 'Test Description'
    });
    // testValue.id will be 35
  });
});

================
File: tests/setup.ts
================
import '@testing-library/jest-dom';

================
File: tests/utils/mockData.ts
================
import { Value } from "@/lib/types";

let currentMockId = 1;

export const createMockValue = (overrides?: Partial<Value>): Value => {
  // Ensure ID stays within 1-35 range, cycling back to 1 if exceeded
  const id = String(overrides?.id ?? currentMockId); // Convert to string
  currentMockId = (currentMockId % 35) + 1;

  return {
    title: 'Mock Title',
    description: 'Mock Description',
    ...overrides,
    // Ensure id stays within valid range even if provided in overrides
    id: typeof overrides?.id === 'number'
    ? String(Math.max(1, Math.min(35, overrides.id))) // Convert to string
    : id
  };
};

// Reset the mock ID counter (useful between test suites)
export const resetMockIdCounter = () => {
  currentMockId = 1;
};

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext",
      "webworker"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ],
      "@/components/*": [
        "./src/components/*"
      ],
      "@/features/*": [
        "./src/components/features/*"
      ],
      "@/common/*": [
        "./src/components/common/*"
      ],
      "@/lib/*": [
        "./src/lib/*"
      ],
      "@/styles/*": [
        "./src/styles/*"
      ],
      "@/assets/*": [
        "./src/assets/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
